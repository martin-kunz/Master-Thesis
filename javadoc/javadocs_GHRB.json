{
  "closure-compiler": "# Javadoc Bundle for closure-compiler\n## com.google.debugging.sourcemap.Base64\n> A utility class for working with Base64 values.\n> A map used to convert integer values in the range 0-63 to their base64\n>  values.\n> A map used to convert base64 character into integer values.\n> @param value A value in the range of 0-63.\n> @return a base64 digit.\n> @param c A base64 digit.\n> @return A value in the range of 0-63.\n> @param value an integer to base64 encode.\n> @return the six digit long base64 encoded value of the integer.\n## com.google.debugging.sourcemap.Base64VLQ\n> We encode our variable length numbers as base64 encoded strings with the least significant digit\n> coming first. Each base64 digit encodes a 5-bit value (0-31) and a continuation bit. Signed\n> values can be represented by using the least significant bit of the value as the sign bit.\n> Converts from a two-complement value to a value where the sign bit is\n> is placed in the least significant bit.  For example, as decimals:\n>   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)\n>   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)\n> Converts to a two-complement value from a value where the sign bit is\n> is placed in the least significant bit.  For example, as decimals:\n>   2 (10 binary) becomes 1, 3 (11 binary) becomes -1\n>   4 (100 binary) becomes 2, 5 (101 binary) becomes -2\n> Writes a VLQ encoded value to the provide appendable.\n> @throws IOException\n> A simple interface for advancing through a sequence of characters, that communicates that\n> advance back to the source.\n> Decodes the next VLQValue from the provided CharIterator.\n## com.google.debugging.sourcemap.FilePosition\n> Represents a position in a source file.\n> Returns the line number of this position.\n> Note: The v1 and v2 source maps use a line number with the first line\n> being 1, whereas the v3 source map corrects this and uses a first line\n> number of 0 to be consistent with the column representation.\n> @return the character index on the line\n> of this position, with the first column being 0.\n## com.google.debugging.sourcemap.SourceMapConsumerV3\n> Class for parsing version 3 of the SourceMap format, as produced by the Closure Compiler, etc.\n> https://github.com/google/closure-compiler/wiki/Source-Maps\n> originalFile path ==> original line ==> target mappings\n> Parses the given contents containing a source map.\n> Parses the given contents containing a source map.\n> @param sourceMapObject\n> @throws SourceMapParseException\n> Returns all extensions and their values (which can be any json value)\n> in a Map object.\n> @return The extension list\n> Decodes the next entry, using the previous encountered values to\n> decode the relative values.\n> @param vals An array of integers that represent values in the entry.\n> @param entryValues The number of entries in the array.\n> @return The entry object.\n> Perform a binary search on the array to find a section that covers\n> the target column.\n> Compare an array entry's column value to the target column value.\n> Returns the mapping entry that proceeds the supplied line or null if no\n> such entry exists.\n> Creates an \"OriginalMapping\" object for the given entry object.\n> Reverse the source map; the created mapping will allow us to quickly go\n> from a source file and line number to a collection of target\n> OriginalMappings.\n> A implementation of the Base64VLQ CharIterator used for decoding the\n> mappings encoded in the JSON string.\n> Represents a mapping entry in the source map.\n> This class represents a portion of the generated file, that is not mapped\n> to a section in the original source.\n> This class represents a portion of the generated file, that is mapped\n> to a section in the original source.\n> This class represents a portion of the generated file, that is mapped\n> to a section in the original source, and is associated with a name.\n## com.google.debugging.sourcemap.SourceMapFormat\n> A list of currently support SourceMap format revisions.\n## com.google.debugging.sourcemap.SourceMapGenerator\n> Collects information mapping the generated (compiled) source back to\n> its original source for debugging purposes\n## com.google.debugging.sourcemap.SourceMapGeneratorFactory\n> @return The appropriate source map object for the given source map format.\n## com.google.debugging.sourcemap.SourceMapParseException\n> Throw if an invalid or unknown source map is encountered.\n## com.google.debugging.sourcemap.Util\n> Escapes the given string to a double quoted (\") JavaScript/JSON string\n> /\n>   static String escapeString(String s) {\n>     final char quote = '\"';\n>     final String doublequoteEscape = \"\\\\\\\"\";\n>     final String singlequoteEscape = \"\\'\";\n>     final String backslashEscape = \"\\\\\\\\\";\n> \n>     StringBuilder sb = new StringBuilder(s.length() + 2);\n>     sb.append(quote);\n> \n>     final class UnescapedRegion {\n>       int unescapedRegionStart = 0;\n>       int unescapedRegionEnd = 0;\n> \n>       void appendUnescaped() {\n>         if (unescapedRegionStart != unescapedRegionEnd) {\n>           // Note: we want to use the \"append(String)\" override\n>           // for performance reasons and the ErrorProne suggestion\n>           // to use the CharSequence override is inferior for that.\n>           sb.append(s.substring(unescapedRegionStart, unescapedRegionEnd));\n>         }\n>         unescapedRegionStart = unescapedRegionEnd;\n>       }\n> \n>       void incrementForNormalChar() {\n>         unescapedRegionEnd++;\n>       }\n> \n>       void incrementForEscapedChar() {\n>         if (unescapedRegionStart != unescapedRegionEnd) {\n>           throw new IllegalStateException();\n>         }\n>         unescapedRegionStart++;\n>         unescapedRegionEnd++;\n>       }\n> \n>       void appendForEscapedChar(String escaped) {\n>         this.appendUnescaped();\n>         this.incrementForEscapedChar();\n>         sb.append(escaped);\n>       }\n>     }\n> \n>     UnescapedRegion region = new UnescapedRegion();\n> \n>     int length = s.length();\n>     for (int i = 0; i < length; i++) {\n>       char c = s.charAt(i);\n>       switch (c) {\n>         case '\\n':\n>           region.appendForEscapedChar(\"\\\\n\");\n>           break;\n>         case '\\r':\n>           region.appendForEscapedChar(\"\\\\r\");\n>           break;\n>         case '\\t':\n>           region.appendForEscapedChar(\"\\\\t\");\n>           break;\n>         case '\\\\':\n>           region.appendForEscapedChar(backslashEscape);\n>           break;\n>         case '\\\"':\n>           region.appendForEscapedChar(doublequoteEscape);\n>           break;\n>         case '\\'':\n>           region.appendForEscapedChar(singlequoteEscape);\n>           break;\n>         case '>':\n>           // Unicode-escape the '>' in '-->' and ']]>'\n>           if (i >= 2\n>               && ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-')\n>                   || (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {\n>             region.appendForEscapedChar(\"\\\\u003e\");\n>           } else {\n>             region.incrementForNormalChar();\n>           }\n>           break;\n>         case '<':\n>           // Unicode-escape the '<' in '</script' and '<!--'\n>           final String END_SCRIPT = \"/script\";\n>           final String START_COMMENT = \"!--\";\n> \n>           if (s.regionMatches(true, i + 1, END_SCRIPT, 0,\n>                               END_SCRIPT.length())) {\n>             region.appendForEscapedChar(\"\\\\u003c\");\n>           } else if (s.regionMatches(false, i + 1, START_COMMENT, 0,\n>                                      START_COMMENT.length())) {\n>             region.appendForEscapedChar(\"\\\\u003c\");\n>           } else {\n>             region.incrementForNormalChar();\n>           }\n>           break;\n>         default:\n>           // No charsetEncoder provided - pass straight Latin characters\n>           // through, and escape the rest.  Doing the explicit character\n>           // check is measurably faster than using the CharsetEncoder.\n>           if (c > 0x1f && c <= 0x7f) {\n>             region.incrementForNormalChar();\n>           } else {\n>             // Other characters can be misinterpreted by some JS parsers,\n>             // or perhaps mangled by proxies along the way,\n>             // so we play it safe and Unicode escape them.\n>             region.appendUnescaped();\n>             region.incrementForEscapedChar();\n>             appendHexJavaScriptRepresentation(sb, c);\n>           }\n>       }\n>     }\n>     region.appendUnescaped();\n>     sb.append(quote);\n>     return sb.toString();\n>   }\n> \n>   /** @see #appendHexJavaScriptRepresentation(int, Appendable)\n> Returns a JavaScript representation of the character in a hex escaped\n> format.\n> @param codePoint The code point to append.\n> @param out The buffer to which the hex representation should be appended.\n## com.google.javascript.jscomp.AbstractCompiler\n> An abstract compiler, to help remove the circular dependency of passes on JSCompiler.\n> <p>This is an abstract class, so that we can make the methods package-private.\n> Will be called before each pass runs.\n> Will be called after each pass finishes.\n> Looks up an input (possibly an externs input) by input id. May return null.\n> Looks up a source file by name. May return null.\n> Gets the module graph.\n> Gets the inputs in the order in which they are being processed. Only for use by {@code\n> AbstractCompilerRunner}.\n> /\n>   abstract Iterable<CompilerInput> getInputsInOrder();\n> \n>   /**\n> Gets the total number of inputs.\n> <p>This can be useful as a guide for the initial allocated size for data structures.\n> /\n>   abstract int getNumberOfInputs();\n> \n>   //\n>   // Intermediate state and results produced and needed by particular passes.\n>   // TODO(rluble): move these into the general structure for keeping state between pass runs.\n>   //\n>   /** Adds exported names to keep track.\n> Gets the names that have been exported.\n> Sets the variable renaming map\n> Sets the property renaming map\n> Sets the string replacement map\n> Sets the css names found during compilation.\n> Sets the mapping for instrumentation parameter encoding.\n> Sets the id generator for cross-module motion.\n> Gets the id generator for cross-module motion.\n> Sets the naming map for anonymous functions\n> Sets whether the typechecking passes have run. */\n>   abstract void setTypeCheckingHasRun(boolean hasRun);\n> \n>   /** Returns whether the typechecking passes have run\n> Whether the AST has been annotated with optimization colors.\n> Returns `true` when type checking has run, but the type registry has been cleared.\n> <p>See also `clearJSTypeRegistry()`.\n> Gets a central registry of type information from the compiled JS.\n## com.google.javascript.jscomp.AbstractScope\n> Scope contains information about a variable scope in JavaScript. Scopes can be nested, a scope\n> points back to its parent scope. A Scope contains information about variables defined in that\n> scope.\n> <p>ES 2015 introduces new scoping rules, which adds some complexity to this class. In particular,\n> scopes fall into two mutually exclusive categories: <i>block</i> and <i>container</i>. Block\n> scopes are all scopes whose roots are blocks, as well as any control structures whose optional\n> blocks are omitted. These scopes did not exist at all prior to ES 2015. Container scopes comprise\n> function scopes, global scopes, and module scopes, and (aside from modules, which didn't exist in\n> ES5) corresponds to the ES5 scope rules. This corresponds roughly to one container scope per CFG\n> root (but not exactly, due to SCRIPT-level CFGs).\n> <p>All container scopes, plus the outermost block scope within a function (i.e. the <i>function\n> block scope</i>) are considered <i>hoist scopes</i>. All functions thus have two hoist scopes:\n> the function scope and the function block scope. Hoist scopes are relevant because \"var\"\n> declarations are hoisted to the closest hoist scope, as opposed to \"let\" and \"const\" which always\n> apply to the specific scope in which they occur.\n> <p>Note that every function actually has two distinct hoist scopes: a container scope on the\n> FUNCTION node, and a block-scope on the top-level BLOCK in the function (the \"function block\").\n> Local variables are declared on the function block, while parameters and optionally the function\n> name (if it bleeds, i.e. from a named function expression) are declared on the container scope.\n> This is required so that default parameter initializers can refer to names from outside the\n> function that could possibly be shadowed in the function block. But these scopes are not fully\n> independent of one another, since the language does not allow a top-level local variable to\n> shadow a parameter name - so in some situations these scopes must be treated as a single scope.\n> @see NodeTraversal\n> The depth of the scope. The global scope has depth 0.\n> Returns the parent scope, or null if this is the global scope.\n> @return True if this scope contains {@code other}, or is the same scope as {@code other}.\n> /\n>   final boolean contains(S other) {\n>     S s = checkNotNull(other);\n>     while (s != null) {\n>       if (s == this) {\n>         return true;\n>       }\n>       s = s.getParent();\n>     }\n>     return false;\n>   }\n> \n>   /**\n> Gets the container node of the scope. This is typically the FUNCTION node or the global\n> BLOCK/SCRIPT node.\n> Walks up the tree to find the global scope.\n> Undeclares a variable, to be used when the compiler optimizes out\n> a variable and removes it from the scope.\n> /\n>   final void undeclare(V var) {\n>     checkState(var.getScope() == this);\n>     checkState(vars.get(var.getName()).equals(var));\n>     undeclareInteral(var);\n>   }\n> \n>   /** Without any safety checks */\n>   final void undeclareInteral(V var) {\n>     // Assume that vars must contain var, and thus not be empty\n>     vars.remove(var.getName());\n>   }\n> \n>   final void declareInternal(String name, V var) {\n>     checkState(hasOwnSlot(name) || canDeclare(name), \"Illegal shadow: %s\", var.getNode());\n> \n>     // For memory savings, only initialize the map once it needs to add its first element\n>     Map<String, V> emptySentinel = ImmutableMap.of();\n>     if (vars == emptySentinel) {\n>       vars = Maps.newLinkedHashMapWithExpectedSize(1);\n>     }\n>     vars.put(name, var);\n>   }\n> \n>   final void clearVarsInternal() {\n>     if (!vars.isEmpty()) {\n>       vars.clear();\n>     }\n>   }\n> \n>   /** Returns true iff this scope implies a slot with the given name.\n> Returns true if a variable is declared in this scope, with no recursion.\n> Returns true if a variable is declared in this or any parent scope.\n> Returns the variable, may be null\n> <p>Non-final for {@link TypedScope} which needs to handle qualified names.\n> Get a unique Var object to represent \"arguments\" within this scope.\n> <p>This explicitly excludes user declared variables that are names \"arguments\". It only returns\n> special \"arguments\" variable that is inherent to a function.\n> Returns true if the name can be declared on this scope without causing illegal shadowing.\n[...truncated...]\n",
  "jhy_jsoup": "# Javadoc Bundle for jsoup\n## org.jsoup.Connection\n> The Connection interface is a convenient HTTP client and session object to fetch content from the web, and parse them\n>  into Documents.\n>  <p>To start a new session, use either {@link org.jsoup.Jsoup#newSession()} or {@link org.jsoup.Jsoup#connect(String)}.\n>  Connections contain {@link Connection.Request} and {@link Connection.Response} objects (once executed). Configuration\n>  settings (URL, timeout, useragent, etc) set on a session will be applied by default to each subsequent request.</p>\n>  <p>To start a new request from the session, use {@link #newRequest()}.</p>\n>  <p>Cookies are stored in memory for the duration of the session. For that reason, do not use one single session for all\n>  requests in a long-lived application, or you are likely to run out of memory, unless care is taken to clean up the\n>  cookie store. The cookie store for the session is available via {@link #cookieStore()}. You may provide your own\n>  implementation via {@link #cookieStore(java.net.CookieStore)} before making requests.</p>\n>  <p>Request configuration can be made using either the shortcut methods in Connection (e.g. {@link #userAgent(String)}),\n>  or by methods in the Connection.Request object directly. All request configuration must be made before the request is\n>  executed. When used as an ongoing session, initialize all defaults prior to making multi-threaded {@link\n> #newRequest()}s.</p>\n>  <p>Note that the term \"Connection\" used here does not mean that a long-lived connection is held against a server for\n>  the lifetime of the Connection object. A socket connection is only made at the point of request execution ({@link\n> #execute()}, {@link #get()}, or {@link #post()}), and the server's response consumed.</p>\n>  <p>For multi-threaded implementations, it is important to use a {@link #newRequest()} for each request. The session may\n>  be shared across threads but a given request, not.</p>\n> GET and POST http methods.\n> Check if this HTTP method has/needs a request body\n> @return if body needed\n> Creates a new request, using this Connection as the session-state and to initialize the connection settings (which may then be independently on the returned Connection.Request object).\n>      @return a new Connection object, with a shared Cookie Store and initialized settings from this Connection and Request\n>      @since 1.14.1\n> /\n>     Connection newRequest();\n> \n>     /**\n> Set the request URL to fetch. The protocol must be HTTP or HTTPS.\n> @param url URL to connect to\n> @return this Connection, for chaining\n> /\n>     Connection url(URL url);\n> \n>     /**\n> Set the request URL to fetch. The protocol must be HTTP or HTTPS.\n> @param url URL to connect to\n> @return this Connection, for chaining\n> /\n>     Connection url(String url);\n> \n>     /**\n> Set the proxy to use for this request. Set to <code>null</code> to disable a previously set proxy.\n> @param proxy proxy to use\n> @return this Connection, for chaining\n> /\n>     Connection proxy(@Nullable Proxy proxy);\n> \n>     /**\n> Set the HTTP proxy to use for this request.\n> @param host the proxy hostname\n> @param port the proxy port\n> @return this Connection, for chaining\n> /\n>     Connection proxy(String host, int port);\n> \n>     /**\n> Set the request user-agent header.\n> @param userAgent user-agent to use\n> @return this Connection, for chaining\n> @see org.jsoup.helper.HttpConnection#DEFAULT_UA\n> /\n>     Connection userAgent(String userAgent);\n> \n>     /**\n> Set the total request timeout duration. If a timeout occurs, an {@link java.net.SocketTimeoutException} will be thrown.\n> <p>The default timeout is <b>30 seconds</b> (30,000 millis). A timeout of zero is treated as an infinite timeout.\n> <p>Note that this timeout specifies the combined maximum duration of the connection time and the time to read\n> the full response.\n> @param millis number of milliseconds (thousandths of a second) before timing out connects or reads.\n> @return this Connection, for chaining\n> @see #maxBodySize(int)\n> /\n>     Connection timeout(int millis);\n> \n>     /**\n> Set the maximum bytes to read from the (uncompressed) connection into the body, before the connection is closed,\n> and the input truncated (i.e. the body content will be trimmed). <b>The default maximum is 2MB</b>. A max size of\n> <code>0</code> is treated as an infinite amount (bounded only by your patience and the memory available on your\n> machine).\n> @param bytes number of bytes to read from the input before truncating\n> @return this Connection, for chaining\n> /\n>     Connection maxBodySize(int bytes);\n> \n>     /**\n> Set the request referrer (aka \"referer\") header.\n> @param referrer referrer to use\n> @return this Connection, for chaining\n> /\n>     Connection referrer(String referrer);\n> \n>     /**\n> Configures the connection to (not) follow server redirects. By default this is <b>true</b>.\n> @param followRedirects true if server redirects should be followed.\n> @return this Connection, for chaining\n> /\n>     Connection followRedirects(boolean followRedirects);\n> \n>     /**\n> Set the request method to use, GET or POST. Default is GET.\n> @param method HTTP request method\n> @return this Connection, for chaining\n> /\n>     Connection method(Method method);\n> \n>     /**\n> Configures the connection to not throw exceptions when a HTTP error occurs. (4xx - 5xx, e.g. 404 or 500). By\n> default this is <b>false</b>; an IOException is thrown if an error is encountered. If set to <b>true</b>, the\n> response is populated with the error body, and the status message will reflect the error.\n> @param ignoreHttpErrors - false (default) if HTTP errors should be ignored.\n> @return this Connection, for chaining\n> /\n>     Connection ignoreHttpErrors(boolean ignoreHttpErrors);\n> \n>     /**\n> Ignore the document's Content-Type when parsing the response. By default this is <b>false</b>, an unrecognised\n> content-type will cause an IOException to be thrown. (This is to prevent producing garbage by attempting to parse\n> a JPEG binary image, for example.) Set to true to force a parse attempt regardless of content type.\n> @param ignoreContentType set to true if you would like the content type ignored on parsing the response into a\n> Document.\n> @return this Connection, for chaining\n> /\n>     Connection ignoreContentType(boolean ignoreContentType);\n> \n>     /**\n> Set custom SSL socket factory\n> @param sslSocketFactory custom SSL socket factory\n> @return this Connection, for chaining\n> /\n>     Connection sslSocketFactory(SSLSocketFactory sslSocketFactory);\n> \n>     /**\n> Add a request data parameter. Request parameters are sent in the request query string for GETs, and in the\n> request body for POSTs. A request may have multiple values of the same name.\n> @param key data key\n> @param value data value\n> @return this Connection, for chaining\n> /\n>     Connection data(String key, String value);\n> \n>     /**\n> Add an input stream as a request data parameter. For GETs, has no effect, but for POSTS this will upload the\n> input stream.\n> @param key data key (form item name)\n> @param filename the name of the file to present to the remove server. Typically just the name, not path,\n> component.\n> @param inputStream the input stream to upload, that you probably obtained from a {@link java.io.FileInputStream}.\n> You must close the InputStream in a {@code finally} block.\n> @return this Connections, for chaining\n> @see #data(String, String, InputStream, String) if you want to set the uploaded file's mimetype.\n> /\n>     Connection data(String key, String filename, InputStream inputStream);\n> \n>     /**\n> Add an input stream as a request data parameter. For GETs, has no effect, but for POSTS this will upload the\n> input stream.\n> @param key data key (form item name)\n> @param filename the name of the file to present to the remove server. Typically just the name, not path,\n> component.\n> @param inputStream the input stream to upload, that you probably obtained from a {@link java.io.FileInputStream}.\n> @param contentType the Content Type (aka mimetype) to specify for this file.\n> You must close the InputStream in a {@code finally} block.\n> @return this Connections, for chaining\n> /\n>     Connection data(String key, String filename, InputStream inputStream, String contentType);\n> \n>     /**\n> Adds all of the supplied data to the request data parameters\n> @param data collection of data parameters\n> @return this Connection, for chaining\n> /\n>     Connection data(Collection<KeyVal> data);\n> \n>     /**\n> Adds all of the supplied data to the request data parameters\n> @param data map of data parameters\n> @return this Connection, for chaining\n> /\n>     Connection data(Map<String, String> data);\n> \n>     /**\n>      Add one or more request {@code key, val} data parameter pairs.<p>Multiple parameters may be set at once, e.g.:\n>      <code>.data(\"name\", \"jsoup\", \"language\", \"Java\", \"language\", \"English\");</code> creates a query string like:\n>      <code>{@literal ?name=jsoup&language=Java&language=English}</code></p>\n>      <p>For GET requests, data parameters will be sent on the request query string. For POST (and other methods that\n>      contain a body), they will be sent as body form parameters, unless the body is explicitly set by {@link\n>     #requestBody(String)}, in which case they will be query string parameters.</p>\n> \n>      @param keyvals a set of key value pairs.\n>      @return this Connection, for chaining\n> /\n>     Connection data(String... keyvals);\n> \n>     /**\n> Get the data KeyVal for this key, if any\n> @param key the data key\n> @return null if not set\n> Set a POST (or PUT) request body. Useful when a server expects a plain request body, not a set for URL\n> encoded form key/value pairs. E.g.:\n> <code><pre>Jsoup.connect(url)\n> .requestBody(json)\n> .header(\"Content-Type\", \"application/json\")\n> .post();</pre></code>\n> If any data key/vals are supplied, they will be sent as URL query params.\n> @return this Request, for chaining\n> /\n>     Connection requestBody(String body);\n> \n>     /**\n> Set a request header.\n> @param name header name\n> @param value header value\n> @return this Connection, for chaining\n> @see org.jsoup.Connection.Request#headers()\n> /\n>     Connection header(String name, String value);\n> \n>     /**\n> Adds each of the supplied headers to the request.\n> @param headers map of headers name {@literal ->} value pairs\n> @return this Connection, for chaining\n> @see org.jsoup.Connection.Request#headers()\n> /\n>     Connection headers(Map<String,String> headers);\n> \n>     /**\n> Set a cookie to be sent in the request.\n> @param name name of cookie\n> @param value value of cookie\n> @return this Connection, for chaining\n> /\n>     Connection cookie(String name, String value);\n> \n>     /**\n> Adds each of the supplied cookies to the request.\n> @param cookies map of cookie name {@literal ->} value pairs\n> @return this Connection, for chaining\n> /\n>     Connection cookies(Map<String, String> cookies);\n> \n>     /**\n>      Provide a custom or pre-filled CookieStore to be used on requests made by this Connection.\n>      @param cookieStore a cookie store to use for subsequent requests\n>      @return this Connection, for chaining\n>      @since 1.14.1\n> /\n>     Connection cookieStore(CookieStore cookieStore);\n> \n>     /**\n>      Get the cookie store used by this Connection.\n>      @return the cookie store\n>      @since 1.14.1\n> /\n>     CookieStore cookieStore();\n> \n>     /**\n> Provide an alternate parser to use when parsing the response to a Document. If not set, defaults to the HTML\n> parser, unless the response content-type is XML, in which case the XML parser is used.\n> @param parser alternate parser\n> @return this Connection, for chaining\n> /\n>     Connection parser(Parser parser);\n> \n>     /**\n> Sets the default post data character set for x-www-form-urlencoded post data\n> @param charset character set to encode post data\n> @return this Connection, for chaining\n> /\n>     Connection postDataCharset(String charset);\n> \n>     /**\n> Execute the request as a GET, and parse the result.\n> @return parsed Document\n> @throws java.net.MalformedURLException if the request URL is not a HTTP or HTTPS URL, or is otherwise malformed\n> @throws HttpStatusException if the response is not OK and HTTP response errors are not ignored\n> @throws UnsupportedMimeTypeException if the response mime type is not supported and those errors are not ignored\n> @throws java.net.SocketTimeoutException if the connection times out\n> @throws IOException on error\n> /\n>     Document get() throws IOException;\n> \n>     /**\n> Execute the request as a POST, and parse the result.\n> @return parsed Document\n> @throws java.net.MalformedURLException if the request URL is not a HTTP or HTTPS URL, or is otherwise malformed\n> @throws HttpStatusException if the response is not OK and HTTP response errors are not ignored\n> @throws UnsupportedMimeTypeException if the response mime type is not supported and those errors are not ignored\n> @throws java.net.SocketTimeoutException if the connection times out\n> @throws IOException on error\n> /\n>     Document post() throws IOException;\n> \n>     /**\n> Execute the request.\n> @return a response object\n> @throws java.net.MalformedURLException if the request URL is not a HTTP or HTTPS URL, or is otherwise malformed\n> @throws HttpStatusException if the response is not OK and HTTP response errors are not ignored\n> @throws UnsupportedMimeTypeException if the response mime type is not supported and those errors are not ignored\n> @throws java.net.SocketTimeoutException if the connection times out\n> @throws IOException on error\n> /\n>     Response execute() throws IOException;\n> \n>     /**\n> Get the request object associated with this connection\n> @return request\n> /\n>     Request request();\n> \n>     /**\n> Set the connection's request\n> @param request new request object\n> @return this Connection, for chaining\n> /\n>     Connection request(Request request);\n> \n>     /**\n> Get the response, once the request has been executed.\n> @return response\n> @throws IllegalArgumentException if called before the response has been executed.\n> /\n>     Response response();\n> \n>     /**\n> Set the connection's response\n> @param response new response\n> @return this Connection, for chaining\n> /\n>     Connection response(Response response);\n> \n>     /**\n> Common methods for Requests and Responses\n> @param <T> Type of Base, either Request or Response\n> Get the URL of this Request or Response. For redirected responses, this will be the final destination URL.\n> @return URL\n> @throws IllegalArgumentException if called on a Request that was created without a URL.\n> /\n>         URL url();\n> \n>         /**\n> Set the URL\n> @param url new URL\n> @return this, for chaining\n> /\n>         T url(URL url);\n> \n>         /**\n> Get the request method, which defaults to <code>GET</code>\n> @return method\n> /\n>         Method method();\n> \n>         /**\n> Set the request method\n> @param method new method\n> @return\n[...truncated...]\n",
  "checkstyle_checkstyle": "# Javadoc Bundle for checkstyle\n## com.puppycrawl.tools.checkstyle.AstTreeStringPrinter\n> Class for printing AST to String.\n> Newline pattern.\n> Return pattern.\n> Tab pattern.\n> OS specific line separator.\n> Prevent instances.\n> Parse a file and print the parse tree.\n> @param file the file to print.\n> @param options {@link JavaParser.Options} to control the inclusion of comment nodes.\n> @return the AST of the file in String form.\n> @throws IOException if the file could not be read.\n> @throws CheckstyleException if the file is not a Java source.\n> Prints full AST (java + comments + javadoc) of the java file.\n> @param file java file\n> @return Full tree\n> @throws IOException Failed to open a file\n> @throws CheckstyleException error while parsing the file\n> Prints full tree (java + comments + javadoc) of the DetailAST.\n> @param ast root DetailAST\n> @return Full tree\n> Parses block comment as javadoc and prints its tree.\n> @param node block comment begin\n> @return string javadoc tree\n> Parse a file and print the parse tree.\n> @param text the text to parse.\n> @param options {@link JavaParser.Options} to control the inclusion of comment nodes.\n> @return the AST of the file in String form.\n> @throws CheckstyleException if the file is not a Java source.\n> Print branch info from root down to given {@code node}.\n> @param node last item of the branch\n> @return branch as string\n> Print AST.\n> @param ast the root AST node.\n> @return string AST.\n> Get string representation of the node as token name,\n> node text, line number and column number.\n> @param node DetailAST\n> @return node info\n> Get indentation for an AST node.\n> @param ast the AST to get the indentation for.\n> @return the indentation in String format.\n> Replace all control chars with escaped symbols.\n> @param text the String to process.\n> @return the processed String with all control chars escaped.\n## com.puppycrawl.tools.checkstyle.Checker\n> This class provides the functionality to check a set of files.\n> Message to use when an exception occurs and should be printed as a violation.\n> Logger for Checker.\n> Maintains error count.\n> Vector of listeners.\n> Vector of fileset checks.\n> The audit event before execution file filters.\n> The audit event filters.\n> The basedir to strip off in file names.\n> Locale country to report messages . *\n> Locale language to report messages . *\n> The factory for instantiating submodules.\n> The classloader used for loading Checkstyle module classes.\n> The context of all child components.\n> The file extensions that are accepted.\n> The severity level of any violations found by submodules.\n> The value of this property is passed to submodules via\n> contextualize().\n> <p>Note: Since the Checker is merely a container for modules\n> it does not make sense to implement logging functionality\n> here. Consequently Checker does not extend AbstractViolationReporter,\n> leading to a bit of duplicated code for severity level setting.\n> Name of a charset.\n> Cache file. *\n> Controls whether exceptions should halt execution or not.\n> The tab width for column reporting.\n## com.puppycrawl.tools.checkstyle.ConfigurationLoader\n> Loads a configuration from a standard configuration XML file.\n> Enum to specify behaviour regarding ignored modules.\n> Omit ignored modules.\n> /\n>         OMIT,\n> \n>         /**\n> Execute ignored modules.\n> /\n>         EXECUTE,\n> \n>     }\n> \n>     /** Format of message for sax parse exception.\n> The public ID for version 1_0 of the configuration dtd.\n> The new public ID for version 1_0 of the configuration dtd.\n> The resource for version 1_0 of the configuration dtd.\n> The public ID for version 1_1 of the configuration dtd.\n> The new public ID for version 1_1 of the configuration dtd.\n> The resource for version 1_1 of the configuration dtd.\n> The public ID for version 1_2 of the configuration dtd.\n> The new public ID for version 1_2 of the configuration dtd.\n> The resource for version 1_2 of the configuration dtd.\n> The public ID for version 1_3 of the configuration dtd.\n> The new public ID for version 1_3 of the configuration dtd.\n> The resource for version 1_3 of the configuration dtd.\n> Prefix for the exception when unable to parse resource.\n> Dollar sign literal.\n> The SAX document handler.\n> Property resolver. *\n> The loaded configurations. *\n## com.puppycrawl.tools.checkstyle.DefaultConfiguration\n> Default implementation of the Configuration interface.\n> @noinspection SerializableHasSerializationMethods\n> A unique serial version identifier.\n> Constant for optimization.\n> The name of this configuration.\n> The list of child Configurations.\n> The map from property names to property values.\n> The map containing custom messages.\n> The thread mode configuration.\n> Instantiates a DefaultConfiguration.\n> @param name the name for this DefaultConfiguration.\n> Instantiates a DefaultConfiguration.\n> @param name the name for this DefaultConfiguration.\n> @param threadModeSettings the thread mode configuration.\n> Makes a configuration a child of this configuration.\n> @param configuration the child configuration.\n> Removes a child of this configuration.\n> @param configuration the child configuration to remove.\n> Adds n property to this configuration.\n> @param attributeName the name of the property.\n> @param value the value of the property.\n> @deprecated This shall be removed in future releases. Please use\n>      {@code addProperty(String propertyName, String value)} instead.\n> Adds n property to this configuration.\n> @param propertyName the name of the property.\n> @param value the value of the property.\n> Adds a custom message to this configuration.\n> @param key the message key\n> @param value the custom message pattern\n> Returns an unmodifiable map instance containing the custom messages\n> for this configuration.\n> @return unmodifiable map containing custom messages\n> Gets the thread mode configuration.\n> @return the thread mode configuration.\n## com.puppycrawl.tools.checkstyle.DefaultLogger\n> Simple plain logger for text output.\n> This is maybe not very suitable for a text output into a file since it\n> does not need all 'audit finished' and so on stuff, but it looks good on\n> stdout anyway. If there is really a problem this is what XMLLogger is for.\n> It gives structure.\n> @see XMLLogger\n> A key pointing to the add exception\n> message in the \"messages.properties\" file.\n> A key pointing to the started audit\n> message in the \"messages.properties\" file.\n> A key pointing to the finished audit\n> message in the \"messages.properties\" file.\n> Where to write info messages. *\n> Close info stream after use.\n> Where to write error messages. *\n> Close error stream after use.\n> Formatter for the log message.\n> Creates a new {@code DefaultLogger} instance.\n> @param outputStream where to log audit events\n> @param outputStreamOptions if {@code CLOSE} that should be closed in auditFinished()\n> Creates a new {@code DefaultLogger} instance.\n> @param infoStream the {@code OutputStream} for info messages.\n> @param infoStreamOptions if {@code CLOSE} info should be closed in auditFinished()\n> @param errorStream the {@code OutputStream} for error messages.\n> @param errorStreamOptions if {@code CLOSE} error should be closed in auditFinished()\n> Creates a new {@code DefaultLogger} instance.\n> @param infoStream the {@code OutputStream} for info messages\n> @param infoStreamOptions if {@code CLOSE} info should be closed in auditFinished()\n> @param errorStream the {@code OutputStream} for error messages\n> @param errorStreamOptions if {@code CLOSE} error should be closed in auditFinished()\n> @param messageFormatter formatter for the log message.\n> @throws IllegalArgumentException if stream options are null\n> @noinspection WeakerAccess\n> Print an Emacs compliant line on the error stream.\n> If the column number is non zero, then also display it.\n> @see AuditListener\n> Flushes the output streams and closes them if needed.\n> Represents a message that can be localised. The translations come from\n> message.properties files. The underlying implementation uses\n> java.text.MessageFormat.\n> A cache that maps bundle names to ResourceBundles.\n> Avoids repetitive calls to ResourceBundle.getBundle().\n> The locale to localise messages to.\n> Key for the message format.\n> Arguments for MessageFormat.\n> Creates a new {@code LocalizedMessage} instance.\n> @param key the key to locate the translation.\n> /\n>         /* package */ LocalizedMessage(String key) {\n>             this.key = key;\n>             args = null;\n>         }\n> \n>         /**\n> Creates a new {@code LocalizedMessage} instance.\n> @param key the key to locate the translation.\n> @param args arguments for the translation.\n> /\n>         /* package */ LocalizedMessage(String key, String... args) {\n>             this.key = key;\n>             if (args == null) {\n>                 this.args = null;\n>             }\n>             else {\n>                 this.args = Arrays.copyOf(args, args.length);\n>             }\n>         }\n> \n>         /**\n> Gets the translated message.\n> @return the translated message.\n## com.puppycrawl.tools.checkstyle.Definitions\n> Contains constant definitions common to the package.\n> Name of resource bundle for Checkstyle.\n> Name of modules which are not checks, but are internal modules.\n> Do no allow {@code Definitions} instances to be created.\n## com.puppycrawl.tools.checkstyle.DetailAstImpl\n> The implementation of {@link DetailAST}. This should only be directly used to\n> create custom AST nodes and in 'JavaAstVisitor.java'.\n> @noinspection FieldNotUsedInToString\n> Constant to indicate if not calculated the child count.\n> The line number. *\n> The column number. *\n> Number of children.\n> The parent token.\n> Previous sibling.\n> First child of this DetailAST.\n> First sibling of this DetailAST.\n> Text of this DetailAST.\n> The type of this DetailAST.\n> All tokens on COMMENTS channel to the left of the current token up to the\n> preceding token on the DEFAULT_TOKEN_CHANNEL.\n> All tokens on COMMENTS channel to the right of the current token up to the\n> next token on the DEFAULT_TOKEN_CHANNEL.\n> All token types in this branch.\n> Token 'x' (where x is an int) is in this branch\n> if branchTokenTypes.get(x) is true.\n> Initializes this DetailAstImpl.\n> @param tokenType the type of this DetailAstImpl\n> @param tokenText the text of this DetailAstImpl\n> Initializes this DetailAstImpl.\n> @param token the token to generate this DetailAstImpl from\n> Add previous sibling.\n> @param ast\n>        DetailAST object.\n> Add next sibling, pushes other siblings back.\n> @param ast DetailAST object.\n> Adds a new child to the current AST.\n> @param child to DetailAST to add as child\n> Set the parent token.\n> @param parent the parent token\n## com.puppycrawl.tools.checkstyle.FileStatefulCheck\n> This annotation means that the check contains file-related context and therefore\n> cannot be used from the others threads at the same time.\n> This annotation should be used when the check holds a thread-unsafe state.\n> Checker guarantees that the whole file processed inside the same thread.\n> Checker guarantees that the whole file processed with the same check instance.\n> Checker guarantees that each check instance processes only one file at the same time.\n> Checker guarantees that all check instances have equal (but not the same) configuration.\n> It means, that if a check holds a property of type \"array of strings\",\n> the property value will not be shared across check instances.\n> Instead, each check instance will hold its own array instance.\n> Checker does not guarantee that each file will have it's own thread -\n> there might be a list of files, which will be executed on the same thread.\n> Checker does not guarantee that each file will have it's own check instance -\n> there might be a list of files, which will be checked by the same instance.\n> Note: Checks with such annotation will be executed in mode how all Checks worked\n> before MT mode is introduced.\n> @noinspection AnnotationClass, ClassIndependentOfModule\n## com.puppycrawl.tools.checkstyle.GlobalStatefulCheck\n> This annotation means that the check contains global context,\n> which will be updated while Checkstyle processes files. This also means,\n> that all files will be processed by the same check instance.\n> This annotation should be used, if a check accumulates some information during the audit,\n> and processed only once at the end of the audit (however, the check still\n> can produce some messages, while collecting information).\n> The check methods and fields should be thread safe, because they may be accessed from others\n> threads at the same time.\n> Checker guarantees that there will be exactly one check instance\n> This is similar to multi-file validation, which checkstyle does not support fully yet.\n> Please refer to https://github.com/checkstyle/checkstyle/issues/3540 for details.\n> @noinspection AnnotationClass, ClassIndependentOfModule, unused, ClassOnlyUsedInOnePackage\n## com.puppycrawl.tools.checkstyle.JavaParser\n> Helper methods to parse java source files.\n> /\n> // -@cs[ClassDataAbstractionCoupling] No way to split up class usage.\n> public final class JavaParser {\n> \n>     /**\n> Enum to be used for test if comments should be used.\n> Comments nodes should be processed.\n> /\n>         WITH_COMMENTS,\n> \n>         /**\n> Comments nodes should be ignored.\n> /\n>         WITHOUT_COMMENTS,\n> \n>     }\n> \n>     /** Stop instances being created. *\n> Static helper method to parses a Java source file.\n> @param contents contains the contents of the file\n> @return the root of the AST\n> @throws CheckstyleException if the contents is not a valid Java source\n> Parse a text and return the parse tree.\n> @param text the text to parse\n> @param options {@link Options} to control inclusion of comment nodes\n> @return the root node of the parse tree\n> @throws CheckstyleException if the text is not a valid Java source\n> Parses Java source file.\n> @param file the file to parse\n> @param options {@link Options} to control inclusion of comment nodes\n> @return DetailAST tree\n> @throws IOException if the file could not be read\n> @throws CheckstyleException if the file is not a valid Java source file\n> Appends comment nodes to existing AST.\n> It traverses each node in AST, looks for hidden comment tokens\n> and appends found comment tokens as nodes in AST.\n> @param root of AST\n> @return root of AST with comment nodes\n> Create comment AST from token. Depending on token type\n> SINGLE_LINE_COMMENT or BLOCK_COMMENT_BEGIN is created.\n> @param token to create the AST\n> @return DetailAST of comment node\n> Create single-line comment from token.\n> @param token to create the AST\n> @return DetailAST with SINGLE_LINE_COMMENT type\n> Custom error listener to provide detailed exception message.\n## com.puppycrawl.tools.checkstyle.JavadocDetailNodeParser\n> Used for parsing Javadoc comment as DetailNode tree.\n> Message key of error message. Missed close HTML tag breaks structure\n> of parse tree, so parser stops parsing and generates such erro\n[...truncated...]\n",
  "scribejava": "# Javadoc Bundle for scribejava\n\n_Konnte kein Quellcode-Verzeichnis finden._",
  "google_gson": "# Javadoc Bundle for gson\n## com.google.gson.ExclusionStrategy\n> A strategy (or policy) definition that is used to decide whether or not a field or top-level\n> class should be serialized or deserialized as part of the JSON output/input. For serialization,\n> if the {@link #shouldSkipClass(Class)} method returns true then that class or field type\n> will not be part of the JSON output. For deserialization, if {@link #shouldSkipClass(Class)}\n> returns true, then it will not be set as part of the Java object structure.\n> <p>The following are a few examples that shows how you can use this exclusion mechanism.\n> <p><strong>Exclude fields and objects based on a particular class type:</strong>\n> <pre class=\"code\">\n> private static class SpecificClassExclusionStrategy implements ExclusionStrategy {\n>   private final Class&lt;?&gt; excludedThisClass;\n>   public SpecificClassExclusionStrategy(Class&lt;?&gt; excludedThisClass) {\n>     this.excludedThisClass = excludedThisClass;\n>   }\n>   public boolean shouldSkipClass(Class&lt;?&gt; clazz) {\n>     return excludedThisClass.equals(clazz);\n>   }\n>   public boolean shouldSkipField(FieldAttributes f) {\n>     return excludedThisClass.equals(f.getDeclaredClass());\n>   }\n> }\n> </pre>\n> <p><strong>Excludes fields and objects based on a particular annotation:</strong>\n> <pre class=\"code\">\n> public &#64;interface FooAnnotation {\n>   // some implementation here\n> }\n> // Excludes any field (or class) that is tagged with an \"&#64;FooAnnotation\"\n> private static class FooAnnotationExclusionStrategy implements ExclusionStrategy {\n>   public boolean shouldSkipClass(Class&lt;?&gt; clazz) {\n>     return clazz.getAnnotation(FooAnnotation.class) != null;\n>   }\n>   public boolean shouldSkipField(FieldAttributes f) {\n>     return f.getAnnotation(FooAnnotation.class) != null;\n>   }\n> }\n> </pre>\n> <p>Now if you want to configure {@code Gson} to use a user defined exclusion strategy, then\n> the {@code GsonBuilder} is required. The following is an example of how you can use the\n> {@code GsonBuilder} to configure Gson to use one of the above sample:\n> <pre class=\"code\">\n> ExclusionStrategy excludeStrings = new UserDefinedExclusionStrategy(String.class);\n> Gson gson = new GsonBuilder()\n>     .setExclusionStrategies(excludeStrings)\n>     .create();\n> </pre>\n> <p>For certain model classes, you may only want to serialize a field, but exclude it for\n> deserialization. To do that, you can write an {@code ExclusionStrategy} as per normal;\n> however, you would register it with the\n> {@link GsonBuilder#addDeserializationExclusionStrategy(ExclusionStrategy)} method.\n> For example:\n> <pre class=\"code\">\n> ExclusionStrategy excludeStrings = new UserDefinedExclusionStrategy(String.class);\n> Gson gson = new GsonBuilder()\n>     .addDeserializationExclusionStrategy(excludeStrings)\n>     .create();\n> </pre>\n> @author Inderjeet Singh\n> @author Joel Leitch\n> @see GsonBuilder#setExclusionStrategies(ExclusionStrategy...)\n> @see GsonBuilder#addDeserializationExclusionStrategy(ExclusionStrategy)\n> @see GsonBuilder#addSerializationExclusionStrategy(ExclusionStrategy)\n> @since 1.4\n> @param f the field object that is under test\n> @return true if the field should be ignored; otherwise false\n> @param clazz the class object that is under test\n> @return true if the class should be ignored; otherwise false\n## com.google.gson.FieldAttributes\n> A data object that stores attributes of a field.\n> <p>This class is immutable; therefore, it can be safely shared across threads.\n> @author Inderjeet Singh\n> @author Joel Leitch\n> @since 1.4\n> Constructs a Field Attributes object from the {@code f}.\n> @param f the field to pull attributes from\n> @return the declaring class that contains this field\n> @return the name of the field\n> <p>For example, assume the following class definition:\n> <pre class=\"code\">\n> public class Foo {\n>   private String bar;\n>   private List&lt;String&gt; red;\n> }\n> Type listParameterizedType = new TypeToken&lt;List&lt;String&gt;&gt;() {}.getType();\n> </pre>\n> <p>This method would return {@code String.class} for the {@code bar} field and\n> {@code listParameterizedType} for the {@code red} field.\n> @return the specific type declared for this field\n> Returns the {@code Class} object that was declared for this field.\n> <p>For example, assume the following class definition:\n> <pre class=\"code\">\n> public class Foo {\n>   private String bar;\n>   private List&lt;String&gt; red;\n> }\n> </pre>\n> <p>This method would return {@code String.class} for the {@code bar} field and\n> {@code List.class} for the {@code red} field.\n> @return the specific class object that was declared for the field\n> Return the {@code T} annotation object from this field if it exist; otherwise returns\n> {@code null}.\n> @param annotation the class of the annotation that will be retrieved\n> @return the annotation instance if it is bound to the field; otherwise {@code null}\n> Return the annotations that are present on this field.\n> @return an array of all the annotations set on the field\n> @since 1.4\n> Returns {@code true} if the field is defined with the {@code modifier}.\n> <p>This method is meant to be called as:\n> <pre class=\"code\">\n> boolean hasPublicModifier = fieldAttribute.hasModifier(java.lang.reflect.Modifier.PUBLIC);\n> </pre>\n> @see java.lang.reflect.Modifier\n## com.google.gson.FieldNamingStrategy\n> A mechanism for providing custom field naming in Gson. This allows the client code to translate\n> field names into a particular convention that is not supported as a normal Java field\n> declaration rules. For example, Java does not support \"-\" characters in a field name.\n> @author Inderjeet Singh\n> @author Joel Leitch\n> @since 1.3\n> Translates the field name into its JSON field name representation.\n> @param f the field object that we are translating\n> @return the translated field name.\n> @since 1.3\n## com.google.gson.Gson\n> This is the main class for using Gson. Gson is typically used by first constructing a\n> Gson instance and then invoking {@link #toJson(Object)} or {@link #fromJson(String, Class)}\n> methods on it. Gson instances are Thread-safe so you can reuse them freely across multiple\n> threads.\n> <p>You can create a Gson instance by invoking {@code new Gson()} if the default configuration\n> is all you need. You can also use {@link GsonBuilder} to build a Gson instance with various\n> configuration options such as versioning support, pretty printing, custom\n> {@link JsonSerializer}s, {@link JsonDeserializer}s, and {@link InstanceCreator}s.</p>\n> <p>Here is an example of how Gson is used for a simple Class:\n> <pre>\n> Gson gson = new Gson(); // Or use new GsonBuilder().create();\n> MyType target = new MyType();\n> String json = gson.toJson(target); // serializes target to Json\n> MyType target2 = gson.fromJson(json, MyType.class); // deserializes json into target2\n> </pre>\n> <p>If the object that your are serializing/deserializing is a {@code ParameterizedType}\n> (i.e. contains at least one type parameter and may be an array) then you must use the\n> {@link #toJson(Object, Type)} or {@link #fromJson(String, Type)} method. Here is an\n> example for serializing and deserializing a {@code ParameterizedType}:\n> <pre>\n> Type listType = new TypeToken&lt;List&lt;String&gt;&gt;() {}.getType();\n> List&lt;String&gt; target = new LinkedList&lt;String&gt;();\n> target.add(\"blah\");\n> Gson gson = new Gson();\n> String json = gson.toJson(target, listType);\n> List&lt;String&gt; target2 = gson.fromJson(json, listType);\n> </pre>\n> <p>See the <a href=\"https://sites.google.com/site/gson/gson-user-guide\">Gson User Guide</a>\n> for a more complete set of examples.</p>\n> @see com.google.gson.reflect.TypeToken\n> @author Inderjeet Singh\n> @author Joel Leitch\n> @author Jesse Wilson\n> This thread local guards against reentrant calls to getAdapter(). In\n> certain object graphs, creating an adapter for a type may recursively\n> require an adapter for the same type! Without intervention, the recursive\n> lookup would stack overflow. We cheat by returning a proxy type adapter.\n> The proxy is wired up once the initial adapter has been created.\n> Constructs a Gson object with default configuration. The default configuration has the\n> following settings:\n> <ul>\n>   <li>The JSON generated by <code>toJson</code> methods is in compact representation. This\n>   means that all the unneeded white-space is removed. You can change this behavior with\n>   {@link GsonBuilder#setPrettyPrinting()}. </li>\n>   <li>The generated JSON omits all the fields that are null. Note that nulls in arrays are\n>   kept as is since an array is an ordered list. Moreover, if a field is not null, but its\n>   generated JSON is empty, the field is kept. You can configure Gson to serialize null values\n>   by setting {@link GsonBuilder#serializeNulls()}.</li>\n>   <li>Gson provides default serialization and deserialization for Enums, {@link Map},\n>   {@link java.net.URL}, {@link java.net.URI}, {@link java.util.Locale}, {@link java.util.Date},\n>   {@link java.math.BigDecimal}, and {@link java.math.BigInteger} classes. If you would prefer\n>   to change the default representation, you can do so by registering a type adapter through\n>   {@link GsonBuilder#registerTypeAdapter(Type, Object)}. </li>\n>   <li>The default Date format is same as {@link java.text.DateFormat#DEFAULT}. This format\n>   ignores the millisecond portion of the date during serialization. You can change\n>   this by invoking {@link GsonBuilder#setDateFormat(int)} or\n>   {@link GsonBuilder#setDateFormat(String)}. </li>\n>   <li>By default, Gson ignores the {@link com.google.gson.annotations.Expose} annotation.\n>   You can enable Gson to serialize/deserialize only those fields marked with this annotation\n>   through {@link GsonBuilder#excludeFieldsWithoutExposeAnnotation()}. </li>\n>   <li>By default, Gson ignores the {@link com.google.gson.annotations.Since} annotation. You\n>   can enable Gson to use this annotation through {@link GsonBuilder#setVersion(double)}.</li>\n>   <li>The default field naming policy for the output Json is same as in Java. So, a Java class\n>   field <code>versionNumber</code> will be output as <code>&quot;versionNumber&quot;</code> in\n>   Json. The same rules are applied for mapping incoming Json to the Java classes. You can\n>   change this policy through {@link GsonBuilder#setFieldNamingPolicy(FieldNamingPolicy)}.</li>\n>   <li>By default, Gson excludes <code>transient</code> or <code>static</code> fields from\n>   consideration for serialization and deserialization. You can change this behavior through\n>   {@link GsonBuilder#excludeFieldsWithModifiers(int...)}.</li>\n> </ul>\n> Returns a new GsonBuilder containing all custom factories and configuration used by the current\n> instance.\n> @return a GsonBuilder instance.\n> @deprecated This method by accident exposes an internal Gson class; it might be removed in a\n> future version.\n> Returns the field naming strategy used by this Gson instance.\n> @see GsonBuilder#setFieldNamingStrategy(FieldNamingStrategy)\n> Returns whether this Gson instance is serializing JSON object properties with\n> {@code null} values, or just omits them.\n> @see GsonBuilder#serializeNulls()\n> Returns whether this Gson instance produces JSON output which is\n> HTML-safe, that means all HTML characters are escaped.\n> @see GsonBuilder#disableHtmlEscaping()\n> Returns the type adapter for {@code} type.\n> @throws IllegalArgumentException if this GSON cannot serialize and\n>     deserialize {@code type}.\n> This method is used to get an alternate type adapter for the specified type. This is used\n> to access a type adapter that is overridden by a {@link TypeAdapterFactory} that you\n> may have registered. This features is typically used when you want to register a type\n> adapter that does a little bit of work but then delegates further processing to the Gson\n> default type adapter. Here is an example:\n> <p>Let's say we want to write a type adapter that counts the number of objects being read\n>  from or written to JSON. We can achieve this by writing a type adapter factory that uses\n>  the <code>getDelegateAdapter</code> method:\n>  <pre> {@code\n>  class StatsTypeAdapterFactory implements TypeAdapterFactory {\n>    public int numReads = 0;\n>    public int numWrites = 0;\n>    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {\n>      final TypeAdapter<T> delegate = gson.getDelegateAdapter(this, type);\n>      return new TypeAdapter<T>() {\n>        public void write(JsonWriter out, T value) throws IOException {\n>          ++numWrites;\n>          delegate.write(out, value);\n>        }\n>        public T read(JsonReader in) throws IOException {\n>          ++numReads;\n>          return delegate.read(in);\n>        }\n>      };\n>    }\n>  }\n>  } </pre>\n>  This factory can now be used like this:\n>  <pre> {@code\n>  StatsTypeAdapterFactory stats = new StatsTypeAdapterFactory();\n>  Gson gson = new GsonBuilder().registerTypeAdapterFactory(stats).create();\n>  // Call gson.toJson() and fromJson methods on objects\n>  System.out.println(\"Num JSON reads\" + stats.numReads);\n>  System.out.println(\"Num JSON writes\" + stats.numWrites);\n>  }</pre>\n>  Note that this call will skip all factories registered before {@code skipPast}. In case of\n>  multiple TypeAdapterFactories registered it is up to the caller of this function to insure\n>  that the order of registration does not prevent this method from reaching a factory they\n>  would expect to reply from this call.\n>  Note that since you can not override type adapter factories for String and Java primitive\n>  types, our stats factory will not count the number of String or primitives that will be\n>  read or written.\n> @param skipPast The type adapter factory that needs to be skipped while searching for\n>   a matching type adapter. In most cases, you should just pass <i>this</i> (the type adapter\n>   factory from where {@code getDelegateAdapter} method is being invoked).\n> @param type Type for which the delegate adapter is being searched for.\n> @since 2.2\n> Returns the type adapter for {@code} type.\n> @throws IllegalArgumentException if this GSON cannot serialize and\n>     deserialize {@code type}.\n> This method serializes the specified object into its equivalent representation as a tree of\n> {@link JsonElement}s. This method should be used when the specified object is not a generic\n> type. This method uses {@link Class#getClass()} to get the type for the specified object, but\n> the {@code getClass()} loses the generic type information because of the Type Erasure feature\n> of Java. Note that this method works fine if the any of the object fields are of generic type,\n> just the object itself should not be of a generic type. If the object is of generic type, use\n> {@link #toJsonTree(Object, Type)} instead.\n> @param src the object for which Json representation is to be created setting for Gson\n> @return Json representation of {@code src}.\n> @since 1.4\n> This method serializes the specified object, including those of gen\n[...truncated...]\n",
  "jjwt": "# Javadoc Bundle for jjwt\n\n_Keine Import-Anweisungen gefunden._",
  "mockito": "# Javadoc Bundle for mockito\n## org.mockito.ArgumentCaptor\n> Use it to capture argument values for further assertions.\n> <p>\n> Mockito verifies argument values in natural java style: by using an equals() method.\n> This is also the recommended way of matching arguments because it makes tests clean and simple.\n> In some situations though, it is helpful to assert on certain arguments after the actual verification.\n> For example:\n> <pre class=\"code\"><code class=\"java\">\n>   ArgumentCaptor&lt;Person&gt; argument = ArgumentCaptor.forClass(Person.class);\n>   verify(mock).doSomething(argument.capture());\n>   assertEquals(\"John\", argument.getValue().getName());\n> </code></pre>\n> Example of capturing varargs:\n> <pre class=\"code\"><code class=\"java\">\n>   //capturing varargs:\n>   ArgumentCaptor&lt;Person&gt; varArgs = ArgumentCaptor.forClass(Person.class);\n>   verify(mock).varArgMethod(varArgs.capture());\n>   List expected = asList(new Person(\"John\"), new Person(\"Jane\"));\n>   assertEquals(expected, varArgs.getAllValues());\n> </code></pre>\n> <p>\n> <strong>Warning:</strong> it is recommended to use ArgumentCaptor with verification <strong>but not</strong> with stubbing.\n> Using ArgumentCaptor with stubbing may decrease test readability because captor is created outside of assert (aka verify or 'then') block.\n> Also it may reduce defect localization because if stubbed method was not called then no argument is captured.\n> <p>\n> In a way ArgumentCaptor is related to custom argument matchers (see javadoc for {@link ArgumentMatcher} class).\n> Both techniques can be used for making sure certain arguments were passed to mocks.\n> However, ArgumentCaptor may be a better fit if:\n> <ul>\n> <li>custom argument matcher is not likely to be reused</li>\n> <li>you just need it to assert on argument values to complete verification</li>\n> </ul>\n> Custom argument matchers via {@link ArgumentMatcher} are usually better for stubbing.\n> <p>\n> This utility class <strong>*doesn't do any type checks*</strong>. The generic signatures are only there to avoid casting\n> in your code.\n> <p>\n> There is an <strong>annotation</strong> that you might find useful: &#64;{@link Captor}\n> <p>\n> See the full documentation on Mockito in javadoc for {@link Mockito} class.\n> @see Captor\n> @since 1.8.0\n> Use it to capture the argument. This method <b>must be used inside of verification</b>.\n> <p>\n> Internally, this method registers a special implementation of an {@link ArgumentMatcher}.\n> This argument matcher stores the argument value so that you can use it later to perform assertions.\n> <p>\n> See examples in javadoc for {@link ArgumentCaptor} class.\n> @return null or default values\n> Returns the captured value of the argument. When capturing varargs use {@link #getAllValues()}.\n> <p>\n> If verified method was called multiple times then this method it returns the latest captured value.\n> <p>\n> See examples in javadoc for {@link ArgumentCaptor} class.\n> @return captured argument value\n> Returns all captured values. Use it when capturing varargs or when the verified method was called multiple times.\n> When varargs method was called multiple times, this method returns merged list of all values from all invocations.\n> <p>\n> Example:\n> <pre class=\"code\"><code class=\"java\">\n>   mock.doSomething(new Person(\"John\");\n>   mock.doSomething(new Person(\"Jane\");\n>   ArgumentCaptor&lt;Person&gt; peopleCaptor = ArgumentCaptor.forClass(Person.class);\n>   verify(mock, times(2)).doSomething(peopleCaptor.capture());\n>   List&lt;Person&gt; capturedPeople = peopleCaptor.getAllValues();\n>   assertEquals(\"John\", capturedPeople.get(0).getName());\n>   assertEquals(\"Jane\", capturedPeople.get(1).getName());\n> </pre>\n> Example of capturing varargs:\n> <pre class=\"code\"><code class=\"java\">\n>   mock.countPeople(new Person(\"John\"), new Person(\"Jane\"); //vararg method\n>   ArgumentCaptor&lt;Person&gt; peopleCaptor = ArgumentCaptor.forClass(Person.class);\n>   verify(mock).countPeople(peopleCaptor.capture());\n>   List expected = asList(new Person(\"John\"), new Person(\"Jane\"));\n>   assertEquals(expected, peopleCaptor.getAllValues());\n> </code></pre>\n> See more examples in javadoc for {@link ArgumentCaptor} class.\n> @return captured argument value\n> Build a new <code>ArgumentCaptor</code>.\n> <p>\n> Note that an <code>ArgumentCaptor</code> <b>*doesn't do any type checks*</b>. It is only there to avoid casting\n> in your code. This might however change (type checks could be added) in a\n> future major release.\n> @param clazz Type matching the parameter to be captured.\n> @param <S> Type of clazz\n> @param <U> Type of object captured by the newly built ArgumentCaptor\n> @return A new ArgumentCaptor\n## org.mockito.ArgumentMatcher\n> Allows creating customized argument matchers.\n> This API was changed in Mockito 2.1.0 in an effort to decouple Mockito from Hamcrest\n> and reduce the risk of version incompatibility.\n> Migration guide is included close to the bottom of this javadoc.\n> <p>\n> For non-trivial method arguments used in stubbing or verification, you have following options\n> (in no particular order):\n> <ul>\n>     <li>refactor the code so that the interactions with collaborators are easier to test with mocks.\n>     Perhaps it is possible to pass a different argument to the method so that mocking is easier?\n>     If stuff is hard to test it usually indicates the design could be better, so do refactor for testability!\n>     </li>\n>     <li>don't match the argument strictly, just use one of the lenient argument matchers like\n>     {@link Mockito#notNull()}. Some times it is better to have a simple test that works than\n>     a complicated test that seem to work.\n>     </li>\n>     <li>implement equals() method in the objects that are used as arguments to mocks.\n>     Mockito naturally uses equals() for argument matching.\n>     Many times, this is option is clean and simple.\n>     </li>\n>     <li>use {@link ArgumentCaptor} to capture the arguments and perform assertions on their state.\n>     Useful when you need to verify the arguments. Captor is not useful if you need argument matching for stubbing.\n>     Many times, this option leads to clean and readable tests with fine-grained validation of arguments.\n>     </li>\n>     <li>use customized argument matchers by implementing {@link ArgumentMatcher} interface\n>     and passing the implementation to the {@link Mockito#argThat} method.\n>     This option is useful if custom matcher is needed for stubbing and can be reused a lot.\n>     Note that {@link Mockito#argThat} demonstrates <b>NullPointerException</b> auto-unboxing caveat.\n>     </li>\n>     <li>use an instance of hamcrest matcher and pass it to\n>     {@link org.mockito.hamcrest.MockitoHamcrest#argThat(org.hamcrest.Matcher)}\n>     Useful if you already have a hamcrest matcher. Reuse and win!\n>     Note that {@link org.mockito.hamcrest.MockitoHamcrest#argThat(org.hamcrest.Matcher)} demonstrates <b>NullPointerException</b> auto-unboxing caveat.\n>     </li>\n>     <li>Java 8 only - use a lambda in place of an {@link ArgumentMatcher} since {@link ArgumentMatcher}\n>     is effectively a functional interface. A lambda can be used with the {@link Mockito#argThat} method.</li>\n> </ul>\n> <p>\n> Implementations of this interface can be used with {@link ArgumentMatchers#argThat} method.\n> Use <code>toString()</code> method for description of the matcher\n> - it is printed in verification errors.\n> <pre class=\"code\"><code class=\"java\">\n> class ListOfTwoElements implements ArgumentMatcher&lt;List&gt; {\n>     public boolean matches(List list) {\n>         return list.size() == 2;\n>     }\n>     public String toString() {\n>         //printed in verification errors\n>         return \"[list of 2 elements]\";\n>     }\n> }\n> List mock = mock(List.class);\n> when(mock.addAll(argThat(new ListOfTwoElements()))).thenReturn(true);\n> mock.addAll(Arrays.asList(&quot;one&quot;, &quot;two&quot;));\n> verify(mock).addAll(argThat(new ListOfTwoElements()));\n> </code></pre>\n> To keep it readable you can extract method, e.g:\n> <pre class=\"code\"><code class=\"java\">\n>   verify(mock).addAll(<b>argThat(new ListOfTwoElements())</b>);\n>   //becomes\n>   verify(mock).addAll(<b>listOfTwoElements()</b>);\n> </code></pre>\n> In Java 8 you can treat ArgumentMatcher as a functional interface\n> and use a lambda, e.g.:\n> <pre class=\"code\"><code class=\"java\">\n>   verify(mock).addAll(<b>argThat(list -&gt; list.size() == 2)</b>);\n> </code></pre>\n> <p>\n> Read more about other matchers in javadoc for {@link ArgumentMatchers} class.\n> <h2>2.1.0 migration guide</h2>\n> All existing custom implementations of <code>ArgumentMatcher</code> will no longer compile.\n> All locations where hamcrest matchers are passed to <code>argThat()</code> will no longer compile.\n> There are 2 approaches to fix the problems:\n> <ul>\n> <li>a) Refactor the hamcrest matcher to Mockito matcher:\n> Use \"implements ArgumentMatcher\" instead of \"extends ArgumentMatcher\".\n> Then refactor <code>describeTo()</code> method into <code>toString()</code> method.\n> </li>\n> <li>\n> b) Use <code>org.mockito.hamcrest.MockitoHamcrest.argThat()</code> instead of <code>Mockito.argThat()</code>.\n> Ensure that there is <a href=\"http://hamcrest.org/JavaHamcrest/\">hamcrest</a> dependency on classpath\n> (Mockito does not depend on hamcrest any more).\n> </li>\n> </ul>\n> What option is right for you? If you don't mind compile dependency to hamcrest\n> then option b) is probably right for you.\n> Your choice should not have big impact and is fully reversible -\n> you can choose different option in future (and refactor the code)\n> @param <T> type of argument\n> @since 2.1.0\n## org.mockito.Captor\n> Allows shorthand {@link org.mockito.ArgumentCaptor} creation on fields.\n> <p>Example:\n> <pre class=\"code\"><code class=\"java\">\n> public class Test{\n>    &#64;Captor ArgumentCaptor&lt;AsyncCallback&lt;Foo&gt;&gt; captor;\n>    private AutoCloseable closeable;\n>    &#64;Before\n>    public void open() {\n>       closeable = MockitoAnnotations.openMocks(this);\n>    }\n>    &#64;After\n>    public void release() throws Exception {\n>       closeable.close();\n>    }\n>    &#64;Test public void shouldDoSomethingUseful() {\n>       //...\n>       verify(mock).doStuff(captor.capture());\n>       assertEquals(\"foo\", captor.getValue());\n>    }\n> }\n> </code></pre>\n> <p>\n> One of the advantages of using &#64;Captor annotation is that you can avoid warnings related capturing complex generic types.\n> @see ArgumentCaptor\n> @since 1.8.3\n## org.mockito.CheckReturnValue\n> This annotation is not supposed to be used by Mockito end-users. Instead, we\n> use it to annotate methods for Static Analysis tools, including FindBugs and ErrorProne.\n> These tools can check whether the return value of our Mockito methods are actually\n> used. As such, Mockito State Validation can be performed at compile-time rather than run-time.\n> This annotation is public, because we have to use it in multiple packages.\n> @see <a href=\"https://github.com/findbugsproject/findbugs/blob/264ae7baf890d2b347d91805c90057062b5dcb1e/findbugs/src/java/edu/umd/cs/findbugs/detect/BuildCheckReturnAnnotationDatabase.java#L120\">Findbugs source code</a>\n> @see <a href=\"https://errorprone.info/bugpattern/CheckReturnValue\">ErrorProne check</a>\n> @since 2.11.4\n## org.mockito.DoNotMock\n> Annotation representing a type that should not be mocked.\n> <p>When marking a type {@code @DoNotMock}, you should always point to alternative testing\n> solutions such as standard fakes or other testing utilities.\n> Mockito enforces {@code @DoNotMock} with the {@link org.mockito.plugins.DoNotMockEnforcer}.\n> If you want to use a custom {@code @DoNotMock} annotation, the {@link org.mockito.plugins.DoNotMockEnforcer}\n> will match on annotations with a type ending in \"org.mockito.DoNotMock\". You can thus place\n> your custom annotation in {@code com.my.package.org.mockito.DoNotMock} and Mockito will enforce\n> that types annotated by {@code @com.my.package.org.mockito.DoNotMock} can not be mocked.\n> <pre class=\"code\"><code class=\"java\">\n> &#064;DoNotMock(reason = \"Use a real instance instead\")\n> class DoNotMockMe {}\n> </code></pre>\n## org.mockito.InOrder\n> Allows verification in order. E.g:\n> <pre class=\"code\"><code class=\"java\">\n> InOrder inOrder = inOrder(firstMock, secondMock);\n> inOrder.verify(firstMock).add(\"was called first\");\n> inOrder.verify(secondMock).add(\"was called second\");\n> </code></pre>\n> As of Mockito 1.8.4 you can verifyNoMoreInteractions() in order-sensitive way. Read more: {@link InOrder#verifyNoMoreInteractions()}\n> <p>\n> See examples in javadoc for {@link Mockito} class\n## org.mockito.InjectMocks\n> Mark a field on which injection should be performed.\n> <ul>\n> <li>Allows shorthand mock and spy injection.</li>\n> <li>Minimizes repetitive mock and spy injection.</li>\n> </ul>\n> <p>\n> Mockito will try to inject mocks only either by constructor injection,\n> property injection or setter injection in order and as described below.\n> If any of the following strategy fail, then Mockito <strong>won't report failure</strong>;\n> i.e. you will have to provide dependencies yourself.\n> <ol>\n>     <li><strong>Constructor injection</strong>; the biggest constructor is chosen,\n>     then arguments are resolved with mocks declared in the test only. If the object is successfully created\n>     with the constructor, then <strong>Mockito won't try the other strategies</strong>. Mockito has decided to no\n>     corrupt an object if it has a parametered constructor.\n>     <p><u>Note:</u> If arguments can not be found, then null is passed.\n>     If non-mockable types are wanted, then constructor injection won't happen.\n>     In these cases, you will have to satisfy dependencies yourself.</p></li>\n>     <li><strong>Property setter injection</strong>; mocks will first be resolved by type (if a single type match\n>     injection will happen regardless of the name),\n>     then, if there is several property of the same type, by the match of the property name and the mock name.\n>     <p><u>Note 1:</u> If you have properties with the same type (or same erasure), it's better to name all &#064;Mock\n>     annotated fields with the matching properties, otherwise Mockito might get confused and injection won't happen.</p>\n>     <p><u>Note 2:</u> If &#064;InjectMocks instance wasn't initialized before and has a no-arg constructor,\n>     then it will be initialized with this constructor.</p></li>\n>     <li><strong>Field injection</strong>; mocks will first be resolved by type (if a single type match\n>     injection will happen regardless of the name),\n>     then, if there is several property of the same type, by the match of the field name and the mock name.\n>     <p><u>Note 1:</u> If you have fields with the same type (or same erasure), it's better to name all &#064;Mock\n>     annotated fields with the matching fields, otherwise Mockito might get confused and injection won't happen.</p>\n>     <p><u>Note 2:</u> If &#064;InjectMocks instance wasn't initialized before and have a \n[...truncated...]\n",
  "guava": "# Javadoc Bundle for guava\n\n_Konnte kein Quellcode-Verzeichnis finden._",
  "flink-cdc-connectors": "# Javadoc Bundle for flink-cdc-connectors\n\n_Konnte kein Quellcode-Verzeichnis finden._",
  "optaplanner": "# Javadoc Bundle for optaplanner\n\n_Konnte kein Quellcode-Verzeichnis finden._",
  "FasterXML_jackson-databind": "# Javadoc Bundle for jackson-databind\n## com.fasterxml.jackson.databind.AbstractTypeResolver\n> Defines interface for resolvers that can resolve abstract types into concrete\n> ones; either by using static mappings, or possibly by materializing\n> implementations dynamically.\n> Try to locate a subtype for given abstract type, to either resolve\n> to a concrete type, or at least to a more-specific (and hopefully supported)\n> abstract type, one which may have registered deserializers.\n> Method is called before trying to locate registered deserializers\n> (as well as standard abstract type defaulting that core Jackson does),\n> so it is typically implemented to add custom mappings of common abstract\n> types (like specify which concrete implementation to use for binding\n> {@link java.util.List}s).\n> <p>\n> Note that this method does not necessarily have to do full resolution\n> of bindings; that is, it is legal to return type that could be further\n> resolved: caller is expected to keep calling this method on registered\n> resolvers, until a concrete type is located.\n> @param config Configuration in use\n> @param type Type to find mapping for\n> @return Type to map given input type (if mapping found) or {@code null} (if not).\n> Older variant of {@link #resolveAbstractType(DeserializationConfig, BeanDescription)};\n> obsoleted in 2.7\n> @deprecated since 2.8 (may be removed from 2.9 or later)\n> @param config Configuration in use\n> @param type Type to resolve\n> @return Resolved concrete type\n> Method called to try to resolve an abstract type into\n> concrete type (usually for purposes of deserializing),\n> when no concrete implementation was found.\n> It will be called after checking all other possibilities,\n> including defaulting.\n> @param config Configuration in use\n> @param typeDesc Description of the POJO type to resolve\n> \n> @return Resolved concrete type (which should retain generic\n>    type parameters of input type, if any), if resolution succeeds;\n>    null if resolver does not know how to resolve given type\n> @since 2.7\n## com.fasterxml.jackson.databind.AnnotationIntrospector\n> Abstract class that defines API used for introspecting annotation-based\n> configuration for serialization and deserialization. Separated\n> so that different sets of annotations can be supported, and support\n> plugged-in dynamically.\n> <p>\n> Although default implementations are based on using annotations as the only\n> (or at least main) information source, custom implementations are not limited\n> in such a way, and in fact there is no expectation they should be. So the name\n> is bit of misnomer; this is a general configuration introspection facility.\n> <p>\n> NOTE: due to rapid addition of new methods (and changes to existing methods),\n> it is <b>strongly</b> recommended that custom implementations should not directly\n> extend this class, but rather extend {@link NopAnnotationIntrospector}.\n> This way added methods will not break backwards compatibility of custom annotation\n> introspectors.\n> *******************************************************************\n>     /* Helper types\n>     /**********************************************************************\n> /\n> \n>     /**\n> Value type used with managed and back references; contains type and\n> logic name, used to link related references\n> Reference property that Jackson manages and that is serialized normally (by serializing\n> reference object), but is used for resolving back references during\n> deserialization.\n> Usually this can be defined by using\n> {@link com.fasterxml.jackson.annotation.JsonManagedReference}\n> /\n>             MANAGED_REFERENCE\n> \n>             /**\n> Reference property that Jackson manages by suppressing it during serialization,\n> and reconstructing during deserialization.\n> Usually this can be defined by using\n> {@link com.fasterxml.jackson.annotation.JsonBackReference}\n> /\n>             ,BACK_REFERENCE\n>             ;\n>         }\n> \n>         private final Type _type;\n>         private final String _name;\n> \n>         public ReferenceProperty(Type t, String n) {\n>             _type = t;\n>             _name = n;\n>         }\n> \n>         public static ReferenceProperty managed(String name) { return new ReferenceProperty(Type.MANAGED_REFERENCE, name); }\n>         public static ReferenceProperty back(String name) { return new ReferenceProperty(Type.BACK_REFERENCE, name); }\n>         \n>         public Type getType() { return _type; }\n>         public String getName() { return _name; }\n> \n>         public boolean isManagedReference() { return _type == Type.MANAGED_REFERENCE; }\n>         public boolean isBackReference() { return _type == Type.BACK_REFERENCE; }\n>     }\n> \n>     /**\n> Add-on extension used for XML-specific configuration, needed to decouple\n> format module functionality from pluggable introspection functionality\n> (especially JAXB-annotation related one).\n> @since 2.13\n> Method that can be called to figure out generic namespace\n> property for an annotated object.\n> @param config Configuration settings in effect\n> @param ann Annotated entity to introspect\n> @return Null if annotated thing does not define any\n>   namespace information; non-null namespace (which may\n>   be empty String) otherwise.\n> Method used to check whether given annotated element\n> (field, method, constructor parameter) has indicator that suggests\n> it be output as an XML attribute or not (if not, then as element)\n> @param config Configuration settings in effect\n> @param ann Annotated entity to introspect\n> @return Null if no indicator found; {@code True} or {@code False} otherwise\n> Method used to check whether given annotated element\n> (field, method, constructor parameter) has indicator that suggests\n> it should be serialized as text, without element wrapper.\n> @param config Configuration settings in effect\n> @param ann Annotated entity to introspect\n> @return Null if no indicator found; {@code True} or {@code False} otherwise\n> Method used to check whether given annotated element\n> (field, method, constructor parameter) has indicator that suggests\n> it should be wrapped in a CDATA tag.\n> @param config Configuration settings in effect\n> @param ann Annotated entity to introspect\n> @return Null if no indicator found; {@code True} or {@code False} otherwise\n> *******************************************************************\n>     /* Factory methods\n>     /**********************************************************************\n> /\n>     \n>     /**\n> Factory method for accessing \"no operation\" implementation\n> of introspector: instance that will never find any annotation-based\n> configuration.\n> @return \"no operation\" instance\n> *******************************************************\n>     /* Access to possibly chained introspectors\n>     /**********************************************************\n> /\n> \n>     /**\n> Method that can be used to collect all \"real\" introspectors that\n> this introspector contains, if any; or this introspector\n> if it is not a container. Used to get access to all container\n> introspectors in their priority order.\n> <p>\n> Default implementation returns a Singleton list with this introspector\n> as contents.\n> This usually works for sub-classes, except for proxy or delegating \"container\n> introspectors\" which need to override implementation.\n> @return Collection of all introspectors starting with this one, in case\n>    multiple introspectors are chained\n> Method that can be used to collect all \"real\" introspectors that\n> this introspector contains, if any; or this introspector\n> if it is not a container. Used to get access to all container\n> introspectors in their priority order.\n> <p>\n> Default implementation adds this introspector in result; this usually\n> works for sub-classes, except for proxy or delegating \"container\n> introspectors\" which need to override implementation.\n> @param result Container to add introspectors to\n> @return Passed in {@code Collection} filled with introspectors as explained\n>    above\n> *******************************************************\n>     /* Default Versioned impl\n>     /**********************************************************\n> *******************************************************\n>     /* Meta-annotations (annotations for annotation types)\n>     /**********************************************************\n> /\n> \n>     /**\n> Method for checking whether given annotation is considered an\n> annotation bundle: if so, all meta-annotations it has will\n> be used instead of annotation (\"bundle\") itself.\n> @param ann Annotated entity to introspect\n> @return True if given annotation is considered an annotation\n>    bundle; false if not\n> *******************************************************\n>     /* Annotations for Object Id handling\n>     /**********************************************************\n> /\n>     \n>     /**\n> Method for checking whether given annotated thing\n> (type, or accessor) indicates that values\n> referenced (values of type of annotated class, or\n> values referenced by annotated property; latter\n> having precedence) should include Object Identifier,\n> and if so, specify details of Object Identity used.\n> @param ann Annotated entity to introspect\n> \n> @return Details of Object Id as explained above, if Object Id\n>    handling to be applied; {@code null} otherwise.\n> Method for figuring out additional properties of an Object Identity reference\n> @param ann Annotated entity to introspect\n> @param objectIdInfo (optional) Base Object Id information, if any; {@code null} if none\n> @return {@link ObjectIdInfo} augmented with possible additional information\n> \n> @since 2.1\n> *******************************************************\n>     /* General class annotations\n>     /**********************************************************\n> /\n> \n>     /**\n> Method for locating name used as \"root name\" (for use by\n> some serializers when outputting root-level object -- mostly\n> for XML compatibility purposes) for given class, if one\n> is defined. Returns null if no declaration found; can return\n> explicit empty String, which is usually ignored as well as null.\n> <p> \n> NOTE: method signature changed in 2.1, to return {@link PropertyName}\n> instead of String.\n> @param ac Annotated class to introspect\n> @return Root name to use, if any; {@code null} if not\n> Method for checking whether properties that have specified type\n> (class, not generics aware) should be completely ignored for\n> serialization and deserialization purposes.\n> \n> @param ac Annotated class to introspect\n> \n> @return Boolean.TRUE if properties of type should be ignored;\n>   Boolean.FALSE if they are not to be ignored, null for default\n>   handling (which is 'do not ignore')\n> Method for finding information about properties to ignore either by\n> name, or by more general specification (\"ignore all unknown\").\n> This method combines multiple aspects of ignorals and deprecates\n> earlier methods such as\n> {@link #findPropertiesToIgnore(Annotated, boolean)} and\n> {@link #findIgnoreUnknownProperties(AnnotatedClass)}.\n> @param config Configuration settings in effect (for serialization or deserialization)\n> @param ann Annotated entity (Class, Accessor) to introspect\n> @return Property ignoral settings to use;\n>   {@code JsonIgnoreProperties.Value.empty()} for defaults (should not return {@code null})\n> @since 2.12 (to replace {@code findPropertyIgnorals()})\n> Method for finding information about names of properties to included.\n> This is typically used to strictly limit properties to include based\n> on fully defined set of names (\"allow-listing\"), as opposed to excluding\n> potential properties by exclusion (\"deny-listing\").\n> @param config Configuration settings in effect (for serialization or deserialization)\n> @param ann Annotated entity (Class, Accessor) to introspect\n> @return Property inclusion settings to use;\n>   {@code JsonIncludeProperties.Value.all()} for defaults (should not return {@code null})\n> @since 2.12\n> Method for finding if annotated class has associated filter; and if so,\n> to return id that is used to locate filter.\n> @param ann Annotated entity to introspect\n> \n> @return Id of the filter to use for filtering properties of annotated\n>    class, if any; or null if none found.\n> Method for finding {@link PropertyNamingStrategy} for given\n> class, if any specified by annotations; and if so, either return\n> a {@link PropertyNamingStrategy} instance, or Class to use for\n> creating instance\n> @param ac Annotated class to introspect\n> @return Sub-class or instance of {@link PropertyNamingStrategy}, if one\n>   is specified for given class; null if not.\n> \n> @since 2.1\n## com.fasterxml.jackson.databind.BeanDescription\n> Basic container for information gathered by {@link ClassIntrospector} to\n> help in constructing serializers and deserializers.\n> Note that the main implementation type is\n> {@link com.fasterxml.jackson.databind.introspect.BasicBeanDescription},\n> meaning that it is safe to upcast to this type.\n> Bean type information, including raw class and possible\n> generics information\n> *******************************************************\n>     /* Life-cycle\n>     /**********************************************************\n> *******************************************************\n>     /* Simple accesors\n>     /**********************************************************\n> /\n> \n>     /**\n> Method for accessing declared type of bean being introspected,\n> including full generic type information (from declaration)\n> @since 2.9\n> Method for accessing low-level information about Class this\n> item describes.\n> Accessor for getting information about Object Id expected to\n> be used for this POJO type, if any.\n> Method for checking whether class being described has any\n> annotations recognized by registered annotation introspector.\n> Accessor for type bindings that may be needed to fully resolve\n> types of member object, such as return and argument types of\n> methods and constructors, and types of fields.\n> @deprecated Since 2.7, should not need to access bindings directly\n> Method for resolving given JDK type, using this bean as the\n> generic type resolution context.\n> @deprecated Since 2.8, should simply call <code>getType</code> of\n>    property accessor directly.\n> Method for accessing collection of annotations the bean\n> class has.\n> *******************************************************\n>     /* Basic API for finding properties\n>     /**********************************************************\n> /\n> \n>     /**\n> @return Ordered Map with logical property name as key, and\n>    matching getter method as value.\n> Method for locating all back-reference properties (setters, fields) bean has\n> @since 2.9\n> Method for locating all back-reference properties (setters, fields) bean has\n> @deprecated Since 2.9 use {@link #findBackReferences()} instead\n> *******************************************************\n>     /* Basic API for finding creator members\n>     /***************************\n[...truncated...]\n",
  "Hakky54_sslcontext-kickstart": "# Javadoc Bundle for sslcontext-kickstart\n## nl.altindag.ssl.SSLFactory\n> @author Hakan Altindag\n> A shorter method for using the unsafe trust material\n> @see Builder#withTrustingAllCertificatesWithoutValidation()\n> @return {@link Builder}\n> Enables the possibility to swap the underlying TrustManager at runtime.\n> After this option has been enabled the TrustManager can be swapped\n> with {@link TrustManagerUtils#swapTrustManager(X509TrustManager, X509TrustManager) TrustManagerUtils#swapTrustManager(swappableTrustManager, newTrustManager)}\n> @return {@link Builder}\n> Enables the possibility to swap the underlying KeyManager at runtime.\n> After this option has been enabled the KeyManager can be swapped\n> with {@link KeyManagerUtils#swapKeyManager(X509KeyManager, X509KeyManager) KeyManagerUtils#swapKeyManager(swappableKeyManager, newKeyManager)}\n> @return {@link Builder}\n## nl.altindag.ssl.exception.GenericCertificateException\n> @author Hakan Altindag\n## nl.altindag.ssl.exception.GenericIOException\n> @author Hakan Altindag\n## nl.altindag.ssl.exception.GenericKeyManagerException\n> @author Hakan Altindag\n## nl.altindag.ssl.exception.GenericKeyStoreException\n> @author Hakan Altindag\n## nl.altindag.ssl.exception.GenericSSLContextException\n> @author Hakan Altindag\n## nl.altindag.ssl.exception.GenericSecurityException\n> @author Hakan Altindag\n## nl.altindag.ssl.exception.GenericTrustManagerException\n> @author Hakan Altindag\n## nl.altindag.ssl.hostnameverifier.BasicHostNameVerifier\n> <strong>NOTE:</strong>\n> Please don't use this class directly as it is part of the internal API. Class name and methods can be changed any time.\n> Instead use the {@link nl.altindag.ssl.util.HostnameVerifierUtils HostnameVerifierUtils} which provides the same functionality\n> while it has a stable API because it is part of the public API.\n> </p>\n> @author Hakan Altindag\n## nl.altindag.ssl.hostnameverifier.UnsafeHostNameVerifier\n> <strong>NOTE:</strong>\n> Please don't use this class directly as it is part of the internal API. Class name and methods can be changed any time.\n> Instead use the {@link nl.altindag.ssl.util.HostnameVerifierUtils HostnameVerifierUtils} which provides the same functionality\n> while it has a stable API because it is part of the public API.\n> </p>\n> @author Hakan Altindag\n## nl.altindag.ssl.keymanager.CompositeX509ExtendedKeyManager\n> Represents an ordered list of {@link X509ExtendedKeyManager} with most-preferred managers first.\n> <p>\n> This is necessary because of the fine-print on {@link javax.net.ssl.SSLContext#init}:\n> Only the first instance of a particular key and/or key manager implementation type in the\n> array is used. (For example, only the first javax.net.ssl.X509KeyManager in the array will be used.)\n> The KeyManager can be build from one or more of any combination provided within the {@link nl.altindag.ssl.util.KeyManagerUtils.KeyManagerBuilder KeyManagerUtils.KeyManagerBuilder}.\n> <br><br>\n> This includes:\n> <pre>\n>     - Any amount of custom KeyManagers\n>     - Any amount of custom Identities\n> </pre>\n> <p>\n> <strong>NOTE:</strong>\n> Please don't use this class directly as it is part of the internal API. Class name and methods can be changed any time.\n> Instead use the {@link nl.altindag.ssl.util.KeyManagerUtils KeyManagerUtils} which provides the same functionality\n> while it has a stable API because it is part of the public API.\n> </p>\n> @see <a href=\"http://stackoverflow.com/questions/1793979/registering-multiple-keystores-in-jvm\">\n>     http://stackoverflow.com/questions/1793979/registering-multiple-keystores-in-jvm\n>     </a>\n> @see <a href=\"http://codyaray.com/2013/04/java-ssl-with-multiple-keystores\">\n>     http://codyaray.com/2013/04/java-ssl-with-multiple-keystores\n>     </a>\n> @author Cody Ray\n> @author Hakan Altindag\n> Creates a new {@link CompositeX509ExtendedKeyManager}.\n> @param keyManagers the {@link X509ExtendedKeyManager}, ordered with the most-preferred managers first.\n> Creates a new {@link CompositeX509ExtendedKeyManager}.\n> @param keyManagers          the {@link X509ExtendedKeyManager}, ordered with the most-preferred managers first.\n> @param preferredAliasToHost the preferred client alias to be used for the given host\n> Chooses the first non-null client alias returned from the delegate\n> {@link X509ExtendedKeyManager}, or {@code null} if there are no matches.\n> Chooses the first non-null client alias returned from the delegate\n> {@link X509ExtendedKeyManager}, or {@code null} if there are no matches.\n> Chooses the first non-null server alias returned from the delegate\n> {@link X509ExtendedKeyManager}, or {@code null} if there are no matches.\n> Chooses the first non-null server alias returned from the delegate\n> {@link X509ExtendedKeyManager}, or {@code null} if there are no matches.\n> Returns the first non-null private key associated with the\n> given alias, or {@code null} if the alias can't be found.\n> Returns the first non-null certificate chain associated with the\n> given alias, or {@code null} if the alias can't be found.\n> Get all matching aliases for authenticating the client side of a\n> secure socket, or {@code null} if there are no matches.\n> Get all matching aliases for authenticating the server side of a\n> secure socket, or {@code null} if there are no matches.\n## nl.altindag.ssl.keymanager.DummyX509ExtendedKeyManager\n> <strong>NOTE:</strong>\n> Please don't use this class directly as it is part of the internal API. Class name and methods can be changed any time.\n> @author Hakan Altindag\n## nl.altindag.ssl.keymanager.HotSwappableX509ExtendedKeyManager\n> <strong>NOTE:</strong>\n> Please don't use this class directly as it is part of the internal API. Class name and methods can be changed any time.\n> Instead use the {@link nl.altindag.ssl.util.KeyManagerUtils KeyManagerUtils} which provides the same functionality\n> while it has a stable API because it is part of the public API.\n> @author Hakan Altindag\n## nl.altindag.ssl.keymanager.KeyManagerFactoryWrapper\n> <strong>NOTE:</strong>\n> Please don't use this class directly as it is part of the internal API. Class name and methods can be changed any time.\n> Instead use the {@link nl.altindag.ssl.util.KeyManagerUtils KeyManagerUtils} which provides the same functionality\n> while it has a stable API because it is part of the public API.\n> @author Hakan Altindag\n## nl.altindag.ssl.keymanager.X509KeyManagerWrapper\n> <strong>NOTE:</strong>\n> Please don't use this class directly as it is part of the internal API. Class name and methods can be changed any time.\n> Instead use the {@link nl.altindag.ssl.util.KeyManagerUtils KeyManagerUtils} which provides the same functionality\n> while it has a stable API because it is part of the public API.\n> @author Hakan Altindag\n## nl.altindag.ssl.model.KeyStoreHolder\n> @author Hakan Altindag\n## nl.altindag.ssl.model.SSLMaterial\n> <p>\n> <strong>NOTE:</strong>\n> Please don't use this class directly as it is part of the internal API. Class name and methods can be changed any time.\n> </p>\n> @author Hakan Altindag\n## nl.altindag.ssl.socket.CompositeSSLServerSocketFactory\n> <strong>NOTE:</strong>\n> Please don't use this class directly as it is part of the internal API. Class name and methods can be changed any time.\n> Instead use the {@link nl.altindag.ssl.util.SSLSocketUtils SSLSocketUtils} which provides the same functionality\n> while it has a stable API because it is part of the public API.\n> @author Hakan Altindag\n## nl.altindag.ssl.socket.CompositeSSLSocketFactory\n> <strong>NOTE:</strong>\n> Please don't use this class directly as it is part of the internal API. Class name and methods can be changed any time.\n> Instead use the {@link nl.altindag.ssl.util.SSLSocketUtils SSLSocketUtils} which provides the same functionality\n> while it has a stable API because it is part of the public API.\n> @author Hakan Altindag\n## nl.altindag.ssl.trustmanager.CertificateCapturingX509ExtendedTrustManager\n> <strong>NOTE:</strong>\n> Please don't use this class directly as it is part of the internal API. Class name and methods can be changed any time.\n> @author Hakan Altindag\n## nl.altindag.ssl.trustmanager.ChainAndAuthTypeValidator\n> @author Hakan Altindag\n## nl.altindag.ssl.trustmanager.ChainAndAuthTypeWithSSLEngineValidator\n> @author Hakan Altindag\n## nl.altindag.ssl.trustmanager.ChainAndAuthTypeWithSocketValidator\n> @author Hakan Altindag\n## nl.altindag.ssl.trustmanager.CompositeX509ExtendedTrustManager\n> {@link CompositeX509ExtendedTrustManager} is a wrapper for a collection of TrustManagers.\n> It has the ability to validate a certificate chain against multiple TrustManagers.\n> If any one of the composed managers trusts a certificate chain, then it is trusted by the composite manager.\n> The TrustManager can be build from one or more of any combination provided within the {@link nl.altindag.ssl.util.TrustManagerUtils.TrustManagerBuilder TrustManagerUtils.TrustManagerBuilder}.\n> <br><br>\n> This includes:\n> <pre>\n>     - Any amount of custom TrustManagers\n>     - Any amount of custom TrustStores\n> </pre>\n> <p>\n> <strong>NOTE:</strong>\n> Please don't use this class directly as it is part of the internal API. Class name and methods can be changed any time.\n> Instead use the {@link nl.altindag.ssl.util.TrustManagerUtils TrustManagerUtils} which provides the same functionality\n> while it has a stable API because it is part of the public API.\n> </p>\n> @see <a href=\"http://stackoverflow.com/questions/1793979/registering-multiple-keystores-in-jvm\">\n>     http://stackoverflow.com/questions/1793979/registering-multiple-keystores-in-jvm\n>     </a>\n> @see <a href=\"http://codyaray.com/2013/04/java-ssl-with-multiple-keystores\">\n>     http://codyaray.com/2013/04/java-ssl-with-multiple-keystores\n>     </a>\n> @author Cody Ray\n> @author Hakan Altindag\n## nl.altindag.ssl.trustmanager.DummyX509ExtendedTrustManager\n> <strong>NOTE:</strong>\n> Please don't use this class directly as it is part of the internal API. Class name and methods can be changed any time.\n> @author Hakan Altindag\n## nl.altindag.ssl.trustmanager.EnhanceableX509ExtendedTrustManager\n> <strong>NOTE:</strong>\n> Please don't use this class directly as it is part of the internal API. Class name and methods can be changed any time.\n> @author Hakan Altindag\n## nl.altindag.ssl.trustmanager.HotSwappableX509ExtendedTrustManager\n> <strong>NOTE:</strong>\n> Please don't use this class directly as it is part of the internal API. Class name and methods can be changed any time.\n> Instead use the {@link nl.altindag.ssl.util.TrustManagerUtils TrustManagerUtils} which provides the same functionality\n> while it has a stable API because it is part of the public API.\n> @author Hakan Altindag\n## nl.altindag.ssl.trustmanager.TrustAnchorTrustOptions\n> @author Hakan Altindag\n## nl.altindag.ssl.trustmanager.TrustManagerFactoryWrapper\n> <strong>NOTE:</strong>\n> Please don't use this class directly as it is part of the internal API. Class name and methods can be changed any time.\n> Instead use the {@link nl.altindag.ssl.util.TrustManagerUtils TrustManagerUtils} which provides the same functionality\n> while it has a stable API because it is part of the public API.\n> @author Hakan Altindag\n## nl.altindag.ssl.trustmanager.TrustStoreTrustOptions\n> @author Hakan Altindag\n## nl.altindag.ssl.trustmanager.UnsafeX509ExtendedTrustManager\n> An insecure {@link UnsafeX509ExtendedTrustManager TrustManager} that trusts all X.509 certificates without any verification.\n> <p>\n> <strong>NOTE:</strong>\n> Never use this {@link UnsafeX509ExtendedTrustManager} in production.\n> It is purely for testing purposes, and thus it is very insecure.\n> </p>\n> <br>\n> Suppressed warning: java:S4830 - \"Server certificates should be verified during SSL/TLS connections\"\n>                                  This TrustManager doesn't validate certificates and should not be used at production.\n>                                  It is just meant to be used for testing purposes and it is designed not to verify server certificates.\n> <p>\n> <br>\n> <strong>NOTE:</strong>\n> Please don't use this class directly as it is part of the internal API. Class name and methods can be changed any time.\n> Instead use the {@link nl.altindag.ssl.util.TrustManagerUtils TrustManagerUtils} which provides the same functionality\n> while it has a stable API because it is part of the public API.\n> </p>\n> @author Hakan Altindag\n## nl.altindag.ssl.trustmanager.X509TrustManagerWrapper\n> <strong>NOTE:</strong>\n> Please don't use this class directly as it is part of the internal API. Class name and methods can be changed any time.\n> Instead use the {@link nl.altindag.ssl.util.TrustManagerUtils TrustManagerUtils} which provides the same functionality\n> while it has a stable API because it is part of the public API.\n> @author Hakan Altindag\n## nl.altindag.ssl.util.HostnameVerifierUtils\n> @author Hakan Altindag\n## nl.altindag.ssl.util.KeyManagerUtils\n> @author Hakan Altindag\n> Wraps the given KeyManager into an instance of a Hot Swappable KeyManager\n> This type of KeyManager has the capability of swapping in and out different KeyManagers at runtime.\n> @param keyManager    To be wrapped KeyManager\n> @return              Swappable KeyManager\n> Swaps the internal KeyManager instance with the given keyManager object.\n> The baseKeyManager should be an instance of {@link HotSwappableX509ExtendedKeyManager}\n> and can be created with {@link KeyManagerUtils#createSwappableKeyManager(X509KeyManager)}\n> @param baseKeyManager                an instance of {@link HotSwappableX509ExtendedKeyManager}\n> @param newKeyManager                 to be injected instance of a KeyManager\n> @throws GenericKeyManagerException   if {@code baseKeyManager} is not instance of {@link HotSwappableX509ExtendedKeyManager}\n## nl.altindag.ssl.util.KeyStoreUtils\n> @author Hakan Altindag\n## nl.altindag.ssl.util.SSLContextUtils\n> @author Hakan Altindag\n## nl.altindag.ssl.util.SSLSessionUtils\n> @author Hakan Altindag\n## nl.altindag.ssl.util.SSLSocketUtils\n> @author Hakan Altindag\n## nl.altindag.ssl.util.StringUtils\n> @author Hakan Altindag\n## nl.altindag.ssl.util.TrustManagerUtils\n> @author Hakan Altindag\n> Wraps the given TrustManager into an instance of a Hot Swappable TrustManager.\n> This type of TrustManager has the capability of swapping in and out different TrustManagers at runtime.\n> @param trustManager  To be wrapped TrustManager\n> @return              Swappable TrustManager\n> Swaps the internal TrustManager instance with the given trustManager object.\n> The baseTrustManager should be an instance of {@link HotSwappableX509ExtendedTrustManager}\n> and can be created with {@link TrustManagerUtils#createSwappableTrustManager(X509TrustManager)}\n> @param baseTrustManager              an instance of {@link HotSwappableX509ExtendedTrustManager}\n> @param newTrustManager               to be injected instance of a TrustManager\n> @throws GenericTrustManagerException if {@code baseTrustManager} is not instance of {@link Hot\n[...truncated...]\n",
  "shardingsphere": "# Javadoc Bundle for shardingsphere\n\n_Keine Import-Anweisungen gefunden._",
  "assertj_assertj-core": "# Javadoc Bundle for assertj-core\n## org.assertj.core.annotations.Beta\n> Signifies that a public API (public class, method or field) is subject to incompatible changes,\n> or even removal, in a future release. An API bearing this annotation is exempt from any\n> compatibility guarantees made by its containing library. Note that the presence of this\n> annotation implies nothing about the quality or performance of the API in question, only the fact\n> that it is not \"API-frozen.\"\n> <p>\n> It is generally safe for <i>applications</i> to depend on beta APIs, at the cost of some extra\n> work during upgrades. However it is generally inadvisable for <i>libraries</i> (which get\n> included on users' CLASSPATHs, outside the library developers' control) to do so.\n> <p>\n> Idea borrowed from Guava.\n## org.assertj.core.api.AbstractAssert\n> Base class for all assertions.\n> @param <SELF> the \"self\" type of this assertion class. Please read &quot;<a href=\"http://bit.ly/1IZIRcY\"\n>          target=\"_blank\">Emulating 'self types' using Java Generics to simplify fluent API implementation</a>&quot;\n>          for more details.\n> @param <ACTUAL> the type of the \"actual\" value.\n> @author Alex Ruiz\n> @author Joel Costigliola\n> @author Mikhail Mazursky\n> @author Nicolas Franois\n> Exposes the {@link WritableAssertionInfo} used in the current assertion for better extensibility.<br> When writing\n> your own assertion class, you can use the returned {@link WritableAssertionInfo} to change the error message and\n> still keep the description set by the assertion user.\n> @return the {@link WritableAssertionInfo} used in the current assertion\n> Throw an assertion error based on information in this assertion. Equivalent to:\n> <pre><code class='java'>throw failure(errorMessage, arguments);</code></pre>\n> <p>\n> This method is a thin wrapper around {@link #failure(String, Object...) failure()} - see that method for a more detailed\n> description.\n> <p>\n> Note that generally speaking, using {@link #failure(String, Object...) failure()} directly is preferable to using this\n> wrapper method, as the compiler and other code analysis tools will be able to tell that the statement will never return\n> normally and respond appropriately.\n> @param errorMessage the error message to format\n> @param arguments the arguments referenced by the format specifiers in the errorMessage string.\n> @see #failWithActualExpectedAndMessage(Object, Object, String, Object...)\n> @see #failure(String, Object...)\n> Generate a custom assertion error using the information in this assertion.\n> <p>\n> This is a utility method to ease writing custom assertions classes using {@link String#format(String, Object...)} specifiers\n> in error message.\n> <p>\n> Moreover, this method honors any description set with {@link #as(String, Object...)} or overridden error message\n> defined by the user with {@link #overridingErrorMessage(String, Object...)}.\n> <p>\n> Example:\n> <pre><code class='java'> public TolkienCharacterAssert hasName(String name) {\n>   // check that actual TolkienCharacter we want to make assertions on is not null.\n>   isNotNull();\n>   // check condition\n>   if (!actual.getName().equals(name)) {\n>     failWithMessage(&quot;Expected character's name to be &lt;%s&gt; but was &lt;%s&gt;&quot;, name, actual.getName());\n>   }\n>   // return the current assertion for method chaining\n>   return this;\n> }</code></pre>\n> @param errorMessage the error message to format\n> @param arguments the arguments referenced by the format specifiers in the errorMessage string.\n> @see #failureWithActualExpected(Object, Object, String, Object...)\n> @see #failWithMessage(String, Object...)\n> @return The generated assertion error.\n> Throw an assertion error based on information in this assertion. Equivalent to:\n> <pre><code class='java'>throw failureWithActualExpected(actual, expected, errorMessageFormat, arguments);</code></pre>\n> <p>\n> This method is a thin wrapper around {@link #failureWithActualExpected(Object, Object, String, Object...) failureWithActualExpected()} -\n> see that method for a more detailed description. Note that generally speaking, using\n> {@link #failureWithActualExpected(Object, Object, String, Object...) failureWithActualExpected()} directly is\n> preferable to using this wrapper method, as the compiler and other code analysis tools will be able to tell that the\n> statement will never return normally and respond appropriately.\n> @param actual the actual object that was found during the test\n> @param expected the object that was expected\n> @param errorMessageFormat the error message to format\n> @param arguments the arguments referenced by the format specifiers in the errorMessage string.\n> @see #failWithMessage(String, Object...)\n> @see #failureWithActualExpected(Object, Object, String, Object...)\n> Generate a custom assertion error using the information in this assertion, using the given actual and expected values.\n> <p>\n> This is a utility method to ease writing custom assertions classes using {@link String#format(String, Object...)} specifiers\n> in error message with actual and expected values.\n> <p>\n> Moreover, this method honors any description set with {@link #as(String, Object...)} or overridden error message\n> defined by the user with {@link #overridingErrorMessage(String, Object...)}.\n> <p>\n> This method also sets the \"actual\" and \"expected\" fields of the assertion if available (eg, if OpenTest4J is on the path).\n> This aids IDEs to produce visual diffs of the resulting values.\n> <p>\n> Example :\n> <pre><code class='java'> public TolkienCharacterAssert hasName(String name) {\n>   // check that actual TolkienCharacter we want to make assertions on is not null.\n>   isNotNull();\n>   // check condition\n>   if (!actual.getName().equals(name)) {\n>     throw failureWithActualExpected(actual.getName(), name, &quot;Expected character's name to be &lt;%s&gt; but was &lt;%s&gt;&quot;, name, actual.getName());\n>   }\n>   // return the current assertion for method chaining\n>   return this;\n> }</code></pre>\n> @param actual the actual object that was found during the test\n> @param expected the object that was expected\n> @param errorMessageFormat the error message to format\n> @param arguments the arguments referenced by the format specifiers in the errorMessage string.\n> @return The generated assertion error.\n> @see #failure(String, Object...)\n> @see #failWithActualExpectedAndMessage(Object, Object, String, Object...)\n> Utility method to throw an {@link AssertionError} given a {@link BasicErrorMessageFactory}.\n> <p>\n> Instead of writing ...\n> <pre><code class='java'> throw Failures.instance().failure(info, ShouldBePresent.shouldBePresent());</code></pre>\n> ... you can simply write :\n> <pre><code class='java'> throwAssertionError(info, ShouldBePresent.shouldBePresent());</code></pre>\n> @param errorMessageFactory used to define the error message.\n> @throws AssertionError with a message corresponding to the given {@link BasicErrorMessageFactory}.\n> Use hexadecimal object representation instead of standard representation in error messages.\n> <p>\n> It can be useful when comparing UNICODE characters - many unicode chars have duplicate characters assigned, it is\n> thus impossible to find differences from the standard error message:\n> <p>\n> With standard message:\n> <pre><code class='java'> assertThat(\"\").contains(\"\");\n> java.lang.AssertionError:\n> Expecting:\n>   &lt;\"\"&gt;\n> to contain:\n>   &lt;\"\"&gt;</code></pre>\n> With Hexadecimal message:\n> <pre><code class='java'> assertThat(\"\").inHexadecimal().contains(\"\");\n> java.lang.AssertionError:\n> Expecting:\n>   &lt;\"['00B5', '00B5', '00B5']\"&gt;\n> to contain:\n>   &lt;\"['03BC', '03BC', '03BC']\"&gt;</code></pre>\n> @return {@code this} assertion object.\n> Use binary object representation instead of standard representation in error messages.\n> <p>\n> Example:\n> <pre><code class='java'> assertThat(1).inBinary().isEqualTo(2);\n> org.junit.ComparisonFailure:\n> Expected :0b00000000_00000000_00000000_00000010\n> Actual   :0b00000000_00000000_00000000_00000001</code></pre>\n> @return {@code this} assertion object.\n> {@inheritDoc}\n> {@inheritDoc}\n> {@inheritDoc}\n> {@inheritDoc}\n> {@inheritDoc}\n> {@inheritDoc}\n> {@inheritDoc}\n> {@inheritDoc}\n> {@inheritDoc}\n> {@inheritDoc}\n> {@inheritDoc}\n## org.assertj.core.api.AbstractDateAssert\n> Base class for all implementations of assertions for {@link Date}s.\n> <p>\n> Note that assertions with date parameter comes with two flavor, one is obviously a {@link Date} and the other is a\n> {@link String} representing a Date.<br>\n> For the latter, the default format follows ISO 8901 : \"yyyy-MM-dd\", user can override it with a custom format by\n> calling {@link #withDateFormat(DateFormat)}.<br>\n> The user custom format will then be used for all next Date assertions (i.e not limited to the current assertion) in\n> the test suite.<br>\n> To turn back to default format, simply call {@link #withDefaultDateFormatsOnly()}.\n> @param <SELF> the \"self\" type of this assertion class. Please read \"<a href=\"http://bit.ly/1IZIRcY\"\n>          target=\"_blank\">Emulating 'self types' using Java Generics to simplify fluent API implementation</a>\" for\n>          more details.\n> @author Tomasz Nurkiewicz (thanks for giving assertions idea)\n> @author Joel Costigliola\n> @author Mikhail Mazursky\n> @author William Delanoue\n> @author Michal Kordas\n> @author Edd Melndez\n> the default DateFormat used to parse any String date representation.\n> Used in String based Date assertions - like {@link #isAfter(String)} - to convert input date represented as string\n> to Date.<br>\n> It keeps the insertion order so first format added will be first format used.\n> Same assertion as {@link AbstractAssert#isEqualTo(Object) isEqualTo(Date date)} but given date is represented as\n> a {@code String} either with one of the supported defaults date format or a user custom date format set with method\n> {@link #withDateFormat(DateFormat)}.\n> <p>\n> User custom date format take precedence over the default ones.\n> <p>\n> Unless specified otherwise, beware that the default formats are expressed in the current local timezone.\n> <p>\n> Example:\n> <pre><code class='java'> // assertion will pass\n> // theTwoTowers release date : 2002-12-18\n> assertThat(theTwoTowers.getReleaseDate()).isEqualTo(\"2002-12-18\");\n> // assertion will fail\n> assertThat(theTwoTowers.getReleaseDate()).isEqualTo(\"2002-12-19\");</code></pre>\n> <p>\n> Defaults date format (expressed in the local time zone unless specified otherwise) are:\n> <ul>\n> <li><code>yyyy-MM-dd'T'HH:mm:ss.SSSX</code> (in ISO Time zone)</li>\n> <li><code>yyyy-MM-dd'T'HH:mm:ss.SSS</code></li>\n> <li><code>yyyy-MM-dd HH:mm:ss.SSS</code></li>\n> <li><code>yyyy-MM-dd'T'HH:mm:ssX</code> (in ISO Time zone)</li>\n> <li><code>yyyy-MM-dd'T'HH:mm:ss</code></li>\n> <li><code>yyyy-MM-dd</code></li>\n> </ul>\n> <p>\n> Example of valid string date representations:\n> <ul>\n> <li><code>2003-04-26T03:01:02.758+00:00</code></li>\n> <li><code>2003-04-26T03:01:02.999</code></li>\n> <li><code>2003-04-26 03:01:02.999</code></li>\n> <li><code>2003-04-26T03:01:02+00:00</code></li>\n> <li><code>2003-04-26T13:01:02</code></li>\n> <li><code>2003-04-26</code></li>\n> </ul>\n> <p>\n> If you are getting an {@code IllegalArgumentException} with <i>\"Unknown pattern character 'X'\"</i> message (some Android versions don't support it),\n> you can explicitly specify the date format to use so that the default ones are bypassed.\n> @param dateAsString the given Date represented as String in default or custom date format.\n> @return this assertion object.\n> @throws AssertionError if actual and given Date represented as String are not equal.\n> @throws AssertionError if the given date as String could not be converted to a Date.\n> Calls {@link AbstractAssert#isEqualTo(Object) isEqualTo(Date date)} after converting the given {@code Instant} to a\n> {@code Date}.\n> <p>\n> Example:\n> <pre><code class='java'> // theTwoTowers release date : 2002-12-18\n> assertThat(theTwoTowers.getReleaseDate()).isEqualTo(Instant.parse(\"2002-12-18T00:00:00.00Z\"));</code></pre>\n> @param instant the given {@code Instant} to compare to actual.\n> @return this assertion object.\n> @throws NullPointerException if given {@code Instant} is {@code null}.\n> @throws AssertionError if actual {@code Date} and given {@link Instant} are not equal (after converting instant to a Date).\n> Same assertion as {@link AbstractDateAssert#isEqualToIgnoringHours(Date)} but given Date is represented as String\n> either with one of the default supported date format or user custom date format (set with method\n> {@link #withDateFormat(DateFormat)}).\n> <p>\n> User custom date format take precedence over the default ones.\n> <p>\n> Unless specified otherwise, beware that the default formats are expressed in the current local timezone.\n> <p>\n> Example:\n> <pre><code class='java'> // OK : all dates fields are the same up to minutes excluded\n> assertThat(\"2003-04-26T13:01:35\").isEqualToIgnoringHours(\"2003-04-26T14:02:35\");\n> // KO : fail as day fields differ\n> assertThat(\"2003-04-26T14:01:35\").isEqualToIgnoringHours(\"2003-04-27T13:02:35\")</code></pre>\n> <p>\n> Defaults date format (expressed in the local time zone unless specified otherwise) are:\n> <ul>\n> <li><code>yyyy-MM-dd'T'HH:mm:ss.SSSX</code> (in ISO Time zone)</li>\n> <li><code>yyyy-MM-dd'T'HH:mm:ss.SSS</code></li>\n> <li><code>yyyy-MM-dd HH:mm:ss.SSS</code></li>\n> <li><code>yyyy-MM-dd'T'HH:mm:ssX</code> (in ISO Time zone)</li>\n> <li><code>yyyy-MM-dd'T'HH:mm:ss</code></li>\n> <li><code>yyyy-MM-dd</code></li>\n> </ul>\n> <p>\n> Example of valid string date representations:\n> <ul>\n> <li><code>2003-04-26T03:01:02.758+00:00</code></li>\n> <li><code>2003-04-26T03:01:02.999</code></li>\n> <li><code>2003-04-26 03:01:02.999</code></li>\n> <li><code>2003-04-26T03:01:02+00:00</code></li>\n> <li><code>2003-04-26T13:01:02</code></li>\n> <li><code>2003-04-26</code></li>\n> </ul>\n> <p>\n> If you are getting an {@code IllegalArgumentException} with <i>\"Unknown pattern character 'X'\"</i> message (some Android versions don't support it),\n> you can explicitly specify the date format to use so that the default ones are bypassed.\n> @param dateAsString the given Date represented as String in default or custom date format.\n> @return this assertion object.\n> @throws AssertionError if actual and given Date represented as String are not equal ignoring hours, minutes,\n>           seconds and milliseconds.\n> @throws AssertionError if the given date as String could not be converted to a Date.\n> Same assertion as {@link AbstractDateAssert#isEqualToIgnoringHours(Date)} but given Date is represented as\n> an {@code java.time.Instant}.\n> <p>\n> Example:\n> <pre><code class='java'> assertThat(new Date()).isEqualToIgnoringHours(Instant.now());</code></pre>\n> @param instant the given {@code Instant}.\n> @return this assertion object.\n> @throws AssertionError if actual {@code Date} and given {@code Instant} are not equal ignoring hours, minutes, seconds and milliseconds.\n> @since \n[...truncated...]\n",
  "jackson-core": "# Javadoc Bundle for jackson-core\n## com.fasterxml.jackson.core.JsonEncoding\n> Enumeration that defines legal encodings that can be used\n> for JSON content, based on list of allowed encodings from\n> <a href=\"http://www.ietf.org/rfc/rfc4627.txt\">JSON specification</a>.\n> <p>\n> Note: if application want to explicitly disregard Encoding\n> limitations (to read in JSON encoded using an encoding not\n> listed as allowed), they can use {@link java.io.Reader} /\n> {@link java.io.Writer} instances as input\n> Method for accessing encoding name that JDK will support.\n> @return Matching encoding name that JDK will support.\n> Whether encoding is big-endian (if encoding supports such\n> notion). If no such distinction is made (as is the case for\n> {@link #UTF8}), return value is undefined.\n> @return True for big-endian encodings; false for little-endian\n>   (or if not applicable)\n## com.fasterxml.jackson.core.JsonFactory\n> The main factory class of Jackson package, used to configure and\n> construct reader (aka parser, {@link JsonParser})\n> and writer (aka generator, {@link JsonGenerator})\n> instances.\n> <p>\n> Factory instances are thread-safe and reusable after configuration\n> (if any). Typically applications and services use only a single\n> globally shared factory instance, unless they need differently\n> configured factories. Factory reuse is important if efficiency matters;\n> most recycling of expensive construct is done on per-factory basis.\n> <p>\n> Creation of a factory instance is a light-weight operation,\n> and since there is no need for pluggable alternative implementations\n> (as there is no \"standard\" JSON processor API to implement),\n> the default constructor is used for constructing factory\n> instances.\n> @author Tatu Saloranta\n> *******************************************************\n>     /* Helper types\n>     /**********************************************************\n> /\n> \n>     /**\n> Enumeration that defines all on/off features that can only be\n> changed for {@link JsonFactory}.\n> Feature that determines whether JSON object field names are\n> to be canonicalized using {@link String#intern} or not:\n> if enabled, all field names will be intern()ed (and caller\n> can count on this being true for all such names); if disabled,\n> no intern()ing is done. There may still be basic\n> canonicalization (that is, same String will be used to represent\n> all identical object property names for a single document).\n> <p>\n> Note: this setting only has effect if\n> {@link #CANONICALIZE_FIELD_NAMES} is true -- otherwise no\n> canonicalization of any sort is done.\n> <p>\n> This setting is enabled by default.\n> /\n>         INTERN_FIELD_NAMES(true),\n> \n>         /**\n> Feature that determines whether JSON object field names are\n> to be canonicalized (details of how canonicalization is done\n> then further specified by\n> {@link #INTERN_FIELD_NAMES}).\n> <p>\n> This setting is enabled by default.\n> /\n>         CANONICALIZE_FIELD_NAMES(true),\n> \n>         /**\n> Feature that determines what happens if we encounter a case in symbol\n> handling where number of hash collisions exceeds a safety threshold\n> -- which almost certainly means a denial-of-service attack via generated\n> duplicate hash codes.\n> If feature is enabled, an {@link IllegalStateException} is\n> thrown to indicate the suspected denial-of-service attack; if disabled, processing continues but\n> canonicalization (and thereby <code>intern()</code>ing) is disabled) as protective\n> measure.\n> <p>\n> This setting is enabled by default.\n> \n> @since 2.4\n> /\n>         FAIL_ON_SYMBOL_HASH_OVERFLOW(true),\n> \n>         /**\n> Feature that determines whether we will use {@link BufferRecycler} with\n> {@link ThreadLocal} and {@link SoftReference}, for efficient reuse of\n> underlying input/output buffers.\n> This usually makes sense on normal J2SE/J2EE server-side processing;\n> but may not make sense on platforms where {@link SoftReference} handling\n> is broken (like Android), or if there are retention issues due to\n> {@link ThreadLocal} (see\n> <a href=\"https://github.com/FasterXML/jackson-core/issues/189\">jackson-core#189</a>\n> for a possible case)\n> <p>\n> This setting is enabled by default.\n> @since 2.6\n> /\n>         USE_THREAD_LOCAL_FOR_BUFFER_RECYCLING(true)\n> \n>         ;\n> \n>         /**\n> Whether feature is enabled or disabled by default.\n> Method that calculates bit set (flags) of all features that\n> are enabled by default.\n> @return Bit field of features enabled by default\n> *******************************************************\n>     /* Constants\n>     /**********************************************************\n> /\n>     \n>     /**\n> Name used to identify JSON format\n> (and returned by {@link #getFormatName()}\n> Bitfield (set of flags) of all factory features that are enabled by default.\n> Bitfield (set of flags) of all parser features that are enabled\n> by default.\n> Bitfield (set of flags) of all generator features that are enabled\n> by default.\n> @since 2.10\n> *******************************************************\n>     /* Buffer, symbol table management\n>     /**********************************************************\n> /\n> \n>     /**\n> Each factory comes equipped with a shared root symbol table.\n> It should not be linked back to the original blueprint, to\n> avoid contents from leaking between factories.\n> Alternative to the basic symbol table, some stream-based\n> parsers use different name canonicalization method.\n> <p>\n> TODO: should clean up this; looks messy having 2 alternatives\n> with not very clear differences.\n> @since 2.6\n> *******************************************************\n>     /* Configuration, simple feature flags\n>     /**********************************************************\n> /\n> \n>     /**\n> Currently enabled factory features.\n> Currently enabled parser features.\n> Currently enabled generator features.\n> *******************************************************\n>     /* Configuration, helper objects\n>     /**********************************************************\n> /\n> \n>     /**\n> Object that implements conversion functionality between\n> Java objects and JSON content. For base JsonFactory implementation\n> usually not set by default, but can be explicitly set.\n> Sub-classes (like @link org.codehaus.jackson.map.MappingJsonFactory}\n> usually provide an implementation.\n> Definition of custom character escapes to use for generators created\n> by this factory, if any. If null, standard data format specific\n> escapes are used.\n> Optional helper object that may decorate input sources, to do\n> additional processing on input during parsing.\n> Optional helper object that may decorate output object, to do\n> additional processing on output during content generation.\n> Separator used between root-level values, if any; null indicates\n> \"do not add separator\".\n> Default separator is a single space character.\n> \n> @since 2.1\n> Optional threshold used for automatically escaping character above certain character\n> code value: either {@code 0} to indicate that no threshold is specified, or value\n> at or above 127 to indicate last character code that is NOT automatically escaped\n> (but depends on other configuration rules for checking).\n> @since 2.10\n## com.fasterxml.jackson.core.JsonGenerator\n> Base class that defines public API for writing JSON content.\n> Instances are created using factory methods of\n> a {@link JsonFactory} instance.\n> @author Tatu Saloranta\n> Default set of {@link StreamWriteCapability}ies that may be used as\n> basis for format-specific readers (or as bogus instance if non-null\n> set needs to be passed).\n> @since 2.12\n> Default set of {@link StreamWriteCapability}ies for typical textual formats,\n> to use either as-is, or as a base with possible differences.\n> @since 2.12\n> Default set of {@link StreamWriteCapability}ies for typical binary formats,\n> to use either as-is, or as a base with possible differences.\n> @since 2.12\n> Enumeration that defines all togglable features for generators.\n> Feature that determines whether generator will automatically\n> close underlying output target that is NOT owned by the\n> generator.\n> If disabled, calling application has to separately\n> close the underlying {@link OutputStream} and {@link Writer}\n> instances used to create the generator. If enabled, generator\n> will handle closing, as long as generator itself gets closed:\n> this happens when end-of-input is encountered, or generator\n> is closed by a call to {@link JsonGenerator#close}.\n> <p>\n> Feature is enabled by default.\n> /\n>         AUTO_CLOSE_TARGET(true),\n> \n>         /**\n> Feature that determines what happens when the generator is\n> closed while there are still unmatched\n> {@link JsonToken#START_ARRAY} or {@link JsonToken#START_OBJECT}\n> entries in output content. If enabled, such Array(s) and/or\n> Object(s) are automatically closed; if disabled, nothing\n> specific is done.\n> <p>\n> Feature is enabled by default.\n> /\n>         AUTO_CLOSE_JSON_CONTENT(true),\n> \n>         /**\n> Feature that specifies that calls to {@link #flush} will cause\n> matching <code>flush()</code> to underlying {@link OutputStream}\n> or {@link Writer}; if disabled this will not be done.\n> Main reason to disable this feature is to prevent flushing at\n> generator level, if it is not possible to prevent method being\n> called by other code (like <code>ObjectMapper</code> or third\n> party libraries).\n> <p>\n> Feature is enabled by default.\n> /\n>         FLUSH_PASSED_TO_STREAM(true),\n> \n>         // // Quoting-related features\n>         \n>         /**\n> Feature that determines whether JSON Object field names are\n> quoted using double-quotes, as specified by JSON specification\n> or not. Ability to disable quoting was added to support use\n> cases where they are not usually expected, which most commonly\n> occurs when used straight from Javascript.\n> <p>\n> Feature is enabled by default (since it is required by JSON specification).\n> @deprecated Since 2.10 use {@link com.fasterxml.jackson.core.json.JsonWriteFeature#QUOTE_FIELD_NAMES} instead\n> Feature that determines whether \"exceptional\" (not real number)\n> float/double values are output as quoted strings.\n> The values checked are Double.Nan,\n> Double.POSITIVE_INFINITY and Double.NEGATIVE_INIFINTY (and \n> associated Float values).\n> If feature is disabled, these numbers are still output using\n> associated literal values, resulting in non-conformant\n> output.\n> <p>\n> Feature is enabled by default.\n> @deprecated Since 2.10 use {@link com.fasterxml.jackson.core.json.JsonWriteFeature#WRITE_NAN_AS_STRINGS} instead\n> Feature that specifies that all characters beyond 7-bit ASCII\n> range (i.e. code points of 128 and above) need to be output\n> using format-specific escapes (for JSON, backslash escapes),\n> if format uses escaping mechanisms (which is generally true\n> for textual formats but not for binary formats).\n> <p>\n> Note that this setting may not necessarily make sense for all\n> data formats (for example, binary formats typically do not use\n> any escaping mechanisms; and some textual formats do not have\n> general-purpose escaping); if so, settings is simply ignored.\n> Put another way, effects of this feature are data-format specific.\n> <p>\n> Feature is disabled by default.\n> @deprecated Since 2.10 use {@link com.fasterxml.jackson.core.json.JsonWriteFeature#ESCAPE_NON_ASCII} instead\n> Feature that forces all Java numbers to be written as Strings,\n> even if the underlying data format has non-textual representation\n> (which is the case for JSON as well as all binary formats).\n> Default state is 'false', meaning that Java numbers are to\n> be serialized using basic numeric serialization (as JSON\n> numbers, integral or floating point, for example).\n> If enabled, all such numeric values are instead written out as\n> textual values (which for JSON means quoted in double-quotes).\n> <p>\n> One use case is to avoid problems with Javascript limitations:\n> since Javascript standard specifies that all number handling\n> should be done using 64-bit IEEE 754 floating point values,\n> result being that some 64-bit integer values can not be\n> accurately represent (as mantissa is only 51 bit wide).\n> <p>\n> Feature is disabled by default.\n> @deprecated Since 2.10 use {@link com.fasterxml.jackson.core.json.JsonWriteFeature#WRITE_NUMBERS_AS_STRINGS} instead\n> Feature that determines whether {@link java.math.BigDecimal} entries are\n> serialized using {@link java.math.BigDecimal#toPlainString()} to prevent\n> values to be written using scientific notation.\n> <p>\n> NOTE: only affects generators that serialize {@link java.math.BigDecimal}s\n> using textual representation (textual formats but potentially some binary\n> formats).\n> <p>\n> Feature is disabled by default, so default output mode is used; this generally\n> depends on how {@link BigDecimal} has been created.\n> \n> @since 2.3\n> /\n>         WRITE_BIGDECIMAL_AS_PLAIN(false),\n> \n>         // // Schema/Validity support features\n> \n>         /**\n> Feature that determines whether {@link JsonGenerator} will explicitly\n> check that no duplicate JSON Object field names are written.\n> If enabled, generator will check all names within context and report\n> duplicates by throwing a {@link JsonGenerationException}; if disabled,\n> no such checking will be done. Assumption in latter case is\n> that caller takes care of not trying to write duplicate names.\n> <p>\n> Note that enabling this feature will incur performance overhead\n> due to having to store and check additional information.\n> <p>\n> Feature is disabled by default.\n> \n> @since 2.3\n> /\n>         STRICT_DUPLICATE_DETECTION(false),\n>         \n>         /**\n> Feature that determines what to do if the underlying data format requires knowledge\n> of all properties to output, and if no definition is found for a property that\n> caller tries to write. If enabled, such properties will be quietly ignored;\n> if disabled, a {@link JsonProcessingException} will be thrown to indicate the\n> problem.\n> Typically most textual data formats do NOT require schema information (although\n> some do, such as CSV), whereas many binary data formats do require definitions\n> (such as Avro, protobuf), although not all (Smile, CBOR, BSON and MessagePack do not).\n> <p>\n> Note that support for this feature is implemented by individual data format\n> module, if (and only if) it makes sense for the format in question. For JSON,\n> for example, this feature has no effect as properties need not be pre-defined.\n> <p>\n> Feature is disabled by default, meaning that if the underlying data format\n> requires knowledge of all properties to output, attempts to write an unknown\n> property will result in a {@link JsonProcessingException}\n> @since 2.5\n> /\n>         IGNORE_UNKNOWN(false),\n>         ;\n> \n>         private final boolean _defaultState;\n>         private final int _mask;\n>         \n>         /**\n> Method that calculates bit set (flags) of all features that\n> are enabled by default.\n> @return Bit field of the features that are enabled by de\n[...truncated...]\n",
  "jackson-parent": "# Javadoc Bundle for jackson-parent\n\n_Konnte kein Quellcode-Verzeichnis finden._",
  "jackson-base": "# Javadoc Bundle for jackson-base\n\n_Konnte kein Quellcode-Verzeichnis finden._"
}